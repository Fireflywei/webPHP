<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>PHP基础</title>
<meta name="viewport" content="initial-scale=1.0,width=device-width" />
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" />
<!--<script   language=javascript>
window.onselectstart=function()   {return   false;}       //禁用选择
window.oncopy=function()   {return   false;}       //禁止复制
</script> -->
<style type="text/css">
li{
   list-style:none;
   padding-left:15px
  }
b{ font-size:18px;font-family: "微软雅黑";}
textarea{
	 width:800px;height:300px;font-size:12px;margin:0;padding:0
}

.homework{
	color:green;font-weight:bold;
}
.homework_div{
   list-style:none;
   padding-left:15px
}


.b2{ font-size:15px;font-family: "微软雅黑";}



#bio p {
clear: left; 
margin:40px auto; 
padding:40px 45px; 
max-width: 1160px; 
background: ###fbfbfb; 
border: 1px solid ###f3f3f3; 
border-radius: 8px; 
position: relative; 
border-width: 0 1px 1px; 
border-color: ###fff ###f3f3f3 ###e8e8e8;
line-height: 1.6em;
font-size: 30px;
font-family: "微软雅黑";

}
span{
font-size:16px;
}
textarea{
resize:none;
}

pre{
	white-space: pre-wrap;
	word-wrap: break-word;
}
</style>
</head>
<body>




<div id="bio">
    <li class="title_white_r" id="st_000" ><h1><a href="###" style="cursor:point;text-decoration:none;">PHP环境安装</a></h1></li>
			<li id="tc_000" style="list-style:none;display:none"></br>
							<ul id="">
							 <div>
<li><h2>使用集成安装环境：AMPServ，或wamp，等都可以</h2></li>
								 
								 </div>
							</ul>
							</li>
</div><br>




<div id="bio">
    <li class="title_white_r" id="st_0" ><h1><a href="###" style="cursor:point;text-decoration:none;">PHP文件必加的头部代码</a></h1></li>
			<li id="tc_0" style="list-style:none;display:none"></br>
							<ul id="">
							 <div>
								 <textarea>

header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误

//如果将秒数设为0,表示无时间上的限制.
//ini_set("memory_limit", 2048576000);//设置内存最大字节数
//ini_set("max_execution_time", 24000);//设置执行时间为24000
//ini_set('default_socket_timeout',24000);//就是设置default_socket_timeout这个配置参

//数为24000意思是socket流的超时时间（参数单位为秒）

								 </textarea></div>
							</ul>
							</li>
</div><br>


<div id="bio">
    <li class="title_white_r" id="st_00" ><h1><a href="###" style="cursor:point;text-decoration:none;">PHP基本语法</a></h1></li>
			<li id="tc_00" style="list-style:none;display:none"></br>
							<ul id="">
							 <div>

   <li><h2>PHP解析标签（内容略）</h2></li>
   <li><h2>变量的声明（内容略）</h2></li>
   <li><h2>变量的类型（内容略）</h2></li>
   <li><h2>变变量（内容略）</h2></li>
   <li><h2>常量（内容略）</h2></li>
   <li><h2>运算符（内容略）</h2></li>
   <li><h2>流程控制（内容略）</h2></li>
   <li><h2>函数（内容略）</h2></li>
   <li><h2 style="color:red">变量作用域（global/$GLOBALS/全局变量/超全局变量($GLOBALS/$_SERVER/$_GET/$_POST/$_FILES/$_SESSION/$_COOKIE/静态变量 static

)/内容略）</h2></li>
   <li><h2>PHP 三个尖括号标签 = &lt;&lt;&lt;ENTRY_DISPLAY（内容略）</h2></li>
   <li><h2>常用调试函数：exit;print_r;echo "&lt;pre&gt;"（内容略）</h2></li>

   
   <li><h2 style="color:red">
	作业：<br>
	1.有一样东西，每天用一半，永远也用不完。当用到第100次时，我不再使用了。写一个函数表达出上述题意<br>
	2.1 用php写一个循环，循环出10个div或者span<br>
	2.2 同时，用php让奇数行和偶数行，前景色 不一样<br>
	2.3 同时，用javascript或者jquery让奇数行和偶数行，背景色 不一样<br>
   </h2></li>
								 
								 </div>
							</ul>
							</li>
</div><br>


<br>

<div id="bio">
    
	<li class="title_white_r" id="st_1" ><h1><a href="###" style="cursor:point;text-decoration:none;">第一部分 字符串函数</a></h1></li>
			<li id="tc_1" style="list-style:none;display:none"></br>
							<ul id="">
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_1">strlen/mb_strlen</a></h1></li></br>
							
							<li id="nr_1" style="display:none;">
							  <ul id="">
							  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_1">strlen  <span>义:返回给定的字符串长度。int strlen  ( string $string  )</span></a></h1></li></br>
							  
							  <li id="de_1" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
  $arr="abcdefg";
  echo "这个字符串的长度是:".strlen($arr);    //输出的是7
       
  $arr="一 二 三 四 五 六 七";                 
  echo "这个字符串的长度是:".strlen($arr);    //在编码为gb2312下输出的是20,一个中文字符为2个长度;在utf-8下输出27,一个中文字符为3个长度
  
  $arr="";
  echo "这个字符串的长度是:".strlen($arr);      //如果字符串为空,输出值为0
								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_2">mb_strlen  <span>义:获取字符串的长度</span> </a></h1></li></br>
							  <li id="de_2" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 
								 
								 
$arr="欢迎来到诺博源软件科技有限公司学习123abc";
 
echo mb_strlen($arr,"utf-8");       //在页面编码为utf-8下长度为23,若不带编码格式,输出的长度则为57,中文每个代表3个字符

echo mb_strlen($arr,"gb2312");      //在页面编码为gb2312下,长度为23,若不带编码格式,输出长度为40,中文每个代表2个字符
注意:mb_strlen后面所带编码必须与页面编码格式一致.


								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							  </ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_2">substr/mb_substr</a></h1></li></br>
							<li id="nr_2" style="display:none;">
							  <ul id="">
							  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_3">substr  <span>义:返回字符串的子串</span></a></h1></li></br>
							  <li id="de_3" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 							 
 $arr2=substr("abcdefg",0,2);
 echo $arr2;                   //输出的是ab,从该字符串位置为0开始,取位置到2之间的内容
 
 $arr="我是a你是b她是c";
echo substr($arr,0,-2);      //输出的是"我是a你是b她",从该字符串位置为0开始,取位置为-2,即倒数位置为2之前长度的内容
								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_4">mb_substr  <span>义:获取字符串的部分</span></a></h1></li></br>
							  <li id="de_4" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 
								 
$string="人生自b古a谁123无死";						 
 $arr=mb_substr($string,1,-1,'utf-8');     //从字符串位置1开始,长度为-1,即从后面数位置为1到正数为1所得出的长度内容
// echo $arr;                    //在页面编码为utf-8下输出的"生自b古a谁123无"
 
 $arr2=mb_substr($string,1,-1,'gb2312');
 echo $arr2;                    //在页面编码为gb2312下输出的"生自b古a谁123无"
 
 注意:mb_substr后面所带编码必须与页面编码格式一致.
 
								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							  </ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_7" >trim  <span>义:此函数返回字符串 str 去除首尾空白字符后的结果。如果不指定第二个参数， trim()将去除这些字符,设置第二个参数会相应剔除字符</span></a></h1></li></br>
							<li id="nr_7" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>
 $text    =  "\t\tThese are a few words :) ...  " ;        //  \t跳格,表示键盘上的"TAB"键
 $hello   =  "欢迎来到开源it-nby" ;
 $trimmed  =  trim ( $text );
 var_dump ( $trimmed );    //打印出的是"These are a few words :) ..."

 $trimmed  =  trim ( $text ,  " \t." );
 var_dump ( $trimmed );      //打印出的是"These are a few words :)",把字符串开始和末尾的\t和.去掉

 $trimmed  =  trim ( $hello ,  "-nby" );
 var_dump ( $trimmed );            //打印出的是 欢迎来到开源it
 //echo $trimmed;
 

$str="\n\r欢迎来到诺博源学习1111\n";         //备注:'\r'是回车，'\n'是换行，前者使光标到行首，后者使光标下移一格，通常敲一个回车键，即是回车，又是换行（\r\n）。Unix中每行结尾只有“<换行>”，即“\n”；Windows中每行结尾是“<换行><回车>”，即“\n\r”
$result=trim($str,"\n\r");
echo $result;
var_dump($result);


 function set_value(& $value){
    $value=trim($value);
 }
 $arr=array("手机"," 电脑","  电话");
 var_dump($arr); 
 array_walk($arr,"set_value");
 var_dump($arr);         //去除掉空格的数组
 
 //业务实例:在进行会员,用户注册,登陆,密码输入时,防止用户在输入信息时不小心加入了空格后,会提示相应错误,所以避免这样的情况出现,我们需要在相应的地方加上trim()
								 </textarea></div>
							  </li>
							  </ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_8">str_replace  <span>义:子字符串替换,该函数返回替换后的数组或者字符串。 </span></a></h1></li></br>
							<li id="nr_8" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>
//对字符串的替换
$arr=str_replace("text","book","this is my text");
echo $arr;     //输出this is my book

//数组的替换
$arr="我有钱,有房,有车";
$reality=array("没钱","没房","没车");
$imaginary=array("有钱","有房","有车");
$result=str_replace($imaginary,$reality,$arr);
echo $result;      //返回字符串输出"我没钱,没房,没车"

业务:当文本中有搜索型关键词时,点击后能跳转到相应的链接
						 </textarea></div>
							  </li>
							  </ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_3">strpos/strripos</a></h1></li></br>
							<li id="nr_3" style="display:none;">
							<ul id="">
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_5">strpos  <span>义:查找字符串首次出现的位置</span></a></h1></li></br>
							<li id="de_5" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 
								 
$arr="abc";
$find="b";
$result=strpos($arr,$find);
echo $result;      //返回其所在位置,以数字的形式,输出1

// 忽视位置偏移量之前的字符进行查找,在此例中忽略了位置从0开始的a,这个要注意下
$newstring  =  'abcdef abcdef' ;
$pos  =  strpos ( $newstring ,  'a' ,  1 );  // $pos = 7, 不是 0
echo $pos;    输出的是7
								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_6">strripos  <span>义:算指定字符串在目标字符串中最后一次出现的位置</span></a></h1></li></br>
								<li id="de_6" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 
								 
$haystack  =  'ababcd1' ;
$needle    =  'Ab' ;
$pos       =  strripos ( $haystack ,  $needle );    //输出的是2,不是0,注意不区分大小写
echo $pos;           //输出的是2                   
//var_dump($pos);
if($pos===false){
  echo "抱歉,找不到";
}else{
  echo "恭喜,找到了";
}
								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							</ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_9">md5 <span>义:计算字符串的 MD5 散列值,以 32 字符十六进制数字形式返回散列值。</span></a></h1></li></br>
							<li id="nr_9" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>
$arr="123";
$result=md5($arr);
echo $result."</br>";
echo strlen($result);

业务:对于用户注册,登陆进行密码注册和输入,为其安全性起见,将使用到MD5函数;进行支付时涉及的MD5签名方式,把订单号,总价提交给支付宝;进行文件储存时,可统一用数字加英文格式的名称


								 </textarea></div>
							  </li>
							  </ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_4">rand/mt_rand</a></h1></li></br>
							<li id="nr_4" style="display:none">
							<ul id="">
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_7">rand <span>义: 产生一个随机整数</span></a></h1></li></br>
							  <li id="de_7" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 
								 
echo rand()."</br>";   //如果不加上范围参数,将随机生成整数
echo rand(1,10)."</br>";
业务:对于商城活动的随机抽奖;形成商品订单,设置规则:如时间日期+固定数字+随机数
echo '生成随机商品订单号为:'.date("YmdHis",time()).'7890'.rand(1000,9999);
								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_8">mt_rand  <span>义:生成更好的随机数,产生随机数的速度比rand()快四倍</span></a></h1></li></br>
							<li id="de_8" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 
 mt_rand()生成的随机数的速度比rand()快四倍,但其作用大致相同

								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							</ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_10">uniqid  <span>义:获取一个带前缀、基于当前时间微秒数的唯一ID。</span></a></h1></li></br>
							<li id="nr_10" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>

获取一个带前缀、基于当前时间微秒数的唯一ID。 
返回字符串形式的唯一ID。 
取唯一,产生唯一的字符串  服务器的主机名和时间产生唯一号   业务:文件上传,避免上传文件名重复式的名称

echo uniqid()."<br>";     //生成唯一ID
echo MD5(uniqid())."<br>";   //结合md5()函数生成一个唯一ID
echo uniqid("abcd")."<br>";   //生成前四位为abcd的唯一ID


								 </textarea></div>
							  </li>
							  </ul>
							</li>
							
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_11">strip_tags  <span>义:从字符串中去除 HTML 和 PHP 标记,带有两个参数.使用可选的第二个参数指定不被去除的字符列表。</span></a></h1></li></br>
							 <li id="nr_11" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>

该函数尝试返回给定的字符串 str 去除空字符、HTML 和 PHP 标记后的结果。它使用与函数 fgetss() 一样的标记去除状态。
返回处理后的字符串。 

$text = '<p>Test paragraph.</p><!-- Comment --> <a href="###fragment">Other text</a>';
echo strip_tags($text);
echo "\n";

// 允许 p标签 和 a标签
echo strip_tags($text, '<p><a>');
//输出：Test paragraph. Other text

业务上:在数据库中存取html标签页,我们要想获得纯文本数据,就需要使用strip_tags对标签的剔除.



								 </textarea></div>
							  </li>
							  </ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_5">addslashes/stripslashes</a></h1></li></br>
							<li id="nr_5" style="display:none">
							<ul id="">
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_9">addslashes  <span>义:返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。<span></a></h1></li></br>
							 <li id="de_9" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 
								 
返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。这些字符是单引号（'）、双引号（"）、反斜线（\）与 NUL（NULL 字符）。
$str = "Is your name O'reilly?";
echo addslashes($str);
//输出Is your name O\'reilly?

业务上:主要用比如URL请求中的id值或站内搜索keyword的文本input，这些往往会附加到SQL的where子句中
      安全性问题								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_10">stripslashes  <span>义:反引用一个引用字符串。</span></a></h1></li></br>
							<li id="de_10" style="display:none">
							   <ul>
							     <li>
								 <div>
								 <textarea>
								 
								 
反引用一个引用字符串。
返回一个去除转义反斜线后的字符串（\' 转换为 ' 等等）。双反斜线（\\）被转换为单个反斜线（\）。
$str = "Is your name O\'reilly?";
echo stripslashes($str);
//输出Is your name O'reilly?
								 </textarea></div>
								 </li>
							   </ul>
							  </li>
							</ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_12">htmlspecialchars  <span>把一些预定义的字符转换为 HTML 实体。</span></a></h1></li></br>
							<li id="nr_12" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>

进行转换 从安全性角度考虑
$new = htmlspecialchars("<a href='test'>Test</a>", ENT_QUOTES);
echo $new; 
//在界面输出<a href='test'>Test</a>   但在页面源代码中显示&lt;a href=&###039;test&###039;&gt;Test&lt;/a&gt;


								 </textarea></div>
							  </li>
							  </ul>
							</li>




							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_133"><font color=red>mb_convert_encoding</font>  <span>字符串编码转换
							</span></a></h1></li></br>
							<li id="nr_133" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>
mb_convert_encoding(字符串,新编码,原编码)
								 </textarea></div>
							  </li>
							  </ul>
							</li>



							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_13">nl2br  <span>在字符串 string 所有新行之前插入 'br/' 或 'br'，并返回。 不同操作系统换行符的不同
							</span></a></h1></li></br>
							<li id="nr_13" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>

在字符串 string 所有新行之前插入 '<br />' 或 '<br>'，并返回。
echo nl2br("foo isn't\n bar \nyes?");
//输出:
foo isn't
 bar
 
  $str="第一个
       第二个
	   第三个
 ";
echo$str;    
//输出"第一个 第二个 第三个"
echo nl2br($str);
//输出:
第一个
第二个
第三个

								 </textarea></div>
							  </li>
							  </ul>
							</li>


							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_6">ucfirst/ucwords/strtolower/strtoupper</a></h1></li></br>
							<li id="nr_6" style="display:none">
							<ul id="">
							<li><h1><a href="###" style="cursor:point;text-decoration:none;">ucfirst  <span>义:将字符串的首字母转换为大写 </span></a></h1></li></br>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;">ucwords  <span>义:将字符串中每个单词的首字母转换为大写 </span></a></h1></li></br>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;">strtolower  <span>义:将字符串转化为小写</span></a></h1></li></br>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;">strtoupper  <span>义:将字符串转化为大写 </span></a></h1></li></br>
							</ul>
							</li>
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_14">str_repeat  <span>义:返回 input 重复 multiplier 次后的结果。</span></a></h1></li></br>
							<li id="nr_14" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>

返回重复后的字符串。
业务:用户星级评论,对商品进行打星评价;文件目录级别显示
echo str_repeat("-=", 10);
//输出-=-=-=-=-=-=-=-=-=-=

$my_head = str_repeat("火", 5); 
echo $my_head;   //输出"火火火火火"
echo strlen($my_head); // 15             页面编码为utf-8
echo mb_strlen($my_head, 'UTF-8');      //输出5


								 </textarea></div>
							  </li>
							  </ul>
							</li>


							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_15">strrev  <span>义:返回 string 反转后的字符串。</span></a></h1></li></br>
							<li id="nr_15" style="display:none">
							  <ul>
							  <li>
							  <div>
								 <textarea>

测试代码,作为作业:进行字符翻转,将字符串后面的放在前面
返回反转后的字符串。 
echo strrev("Hello world!"); 
//输出 "!dlrow olleH"


								 </textarea></div>
							  </li>
							  </ul>
							</li>
							</ul>
							
							<ul id="">
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_16">作业</a></h1></li></br>
				<li id="nr_16" style="display:none">
				 <ul>
				   <li>
				   <div>
								 <textarea>

1.将一篇文章的百度或其他的替换成链接
2.写个函数来实现跟strrev同样的效果,进行字符翻转,将字符串后面的放在前面。（同时用javascript实现）
3.用字符串函数获取文件后缀。（同时用javascript实现）
4.ucfirst/ucwords/strtolower/strtoupper进行代码测试
5.strip_tags编写测试代码,看js能否过滤掉
6.按照自己想法，将字符串函数分类
7.让2个数一共随机出现100次，计算它们出现的频率各是多少


								 </textarea></div>
				   </li>
				 </ul>
				</li>	
				
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_54">部分答案</a></h1></li></br>
				<li id="nr_54" style="display:none">
				 <ul>
				   <li>
				   <div>
								 <textarea>

1.将一篇文章的百度或其他的替换成链接
$content="李白（701年2月8日—762年12月）[1]  ，字太白，号青莲居士，又号“谪仙人”。是唐代伟大的浪漫主义诗人，被后人誉为“诗仙”。与杜甫并称为“李杜”，为了与另两位诗人李商隐与杜牧即“小李杜”区别，杜甫与李白又合称“大李杜”。其人爽朗大方，爱饮酒作诗，喜交友。
李白有《李太白集》传世，诗作中多以醉时写的，代表作有《望庐山瀑布》、《行路难》、《蜀道难》、《将进酒》、《梁甫吟》、《早发白帝城》等多首。
李白所作词赋，宋人已有传记（如文莹《湘山野录》卷上），就其开创意义及艺术成就而言，“李白词”享有极为崇高的地位。";
$search=array("李白","杜甫","浪漫主义","青莲居士");
$repalce=array("<a href='http://baike.baidu.com/link?url=YxaEDARLRMcd61Ba7X7YZCUU1_MkxTAEqeIjseKpSDHTifRIEhHWa9vjtgxT4uJXD6t0cKNxZbKVEyCAfom0JX1o3OGmslgZkYvFQB_QVV_'>李白</a>","<a href='http://baike.baidu.com/link?url=PLSL6f8rB4s8_0wBl1csu0QBC9ErPzOOWg1w__OcdOAiXFOcdcpSnGcJNOasECdKePbEiTsZMdbMpq6ow08zeg7OP0w6bcYtJjxwdRXAIZ_'>杜甫</a>","<a href='http://baike.baidu.com/link?url=muJ9JOHhIKQa_hptiwmvQg6sMoN4TluEdRFoUK7BKHgSw8fRDB83YsxPcbHGLZ6-1n5j81kAWMEQgRVE6R3nsK'>浪漫主义</a>","<a href='http://baike.baidu.com/subview/2133/5052678.htm?fromtitle=%E9%9D%92%E8%8E%B2%E5%B1%85%E5%A3%AB&fromid=1352441&type=syn'>青莲居士</a>");
$result=str_replace($search,$repalce,$content);
echo $result


2.写个函数来实现跟strrev同样的效果,进行字符翻转,将字符串后面的放在前面
function y($str){
  $str2="";
  for($i=0;$i<mb_strlen($str,'utf-8');$i++) {
    $s=mb_substr($str,$i,1,'utf-8');
    $str2=$s.$str2;
  }

  return $str2;
}

echo y("可用2于获取a数组b中的值");


5.strip_tags编写测试代码,看js能否过滤掉
echo "<script>";
echo "function a(){
   alert(111);
}";
echo "</script>";
$a="<div onclick='a();'>aaaaa</div>"
echo $a;                            //能弹出窗口
echo strip_tags($a);                       //不能弹出



								 </textarea></div>
				   </li>
				 </ul>
				</li>		
			</li>
			</ul>

			
</div></br>

<div id="bio">
	<li class="title_white_r" id="st_2" >
		<h1><a href="###" style="cursor:point;text-decoration:none;">第二部分 数组函数</a></h1>
	</li>
			
	<li id="tc_2" style="list-style:none;display:none">
	
		</br>
		<ul id="">
			<li>
				<h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_25">数组的创建</a></h1>
			</li>
			</br>

			<li id="nr_25" style="list-style:none;display:none">
				<ul>
					<li>
						<div>
							<textarea>

什么是数组?
实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型.


数组创建的几种方式
一:  array("$key"=>"$val");
$arr=array("a"=>"这是a","b"=>"这是b","c"=>"这是c");
echo "<pre>";
print_r($arr);

创建二维数组
$arr=array("a"=>"这是a",array("b"=>"这是b","这个是什么"),"c"=>"这是c");
echo "<pre>";
print_r($arr);

二:array[];
$arr[1]="张三";
$arr[2]="李四";
$arr[3]="王五";
$arr[4]="赵六";
echo "<pre>";
print_r($arr);

创建二维数组
$arr[0]="这是0";
$arr[1][0]="这是0";
$arr["a"]="这是a";
echo "<pre>";
print_r($arr);

三:array("","","");
$arr=array("a","b","c","d");
echo "<pre>";
print_r($arr);   

创建多维数组
$arr=array("a",array("aa",array("bb","ee")),"c","d");
echo "<pre>";
print_r($arr);      
注意:用第三种方法时,数组函数的下标即键值是从0开始的.

								 </textarea>
							 </div>
						</li>
					</ul>
				</li>
				

		<li>
					<h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_26"><font color=red>range</font>/compact  <span>义:建立一个数组。包括变量名和它们的值 。在当前的符号表中查找该变量名并将它添加到输出的数组中，变量名成为键名而变量的内容成为该键的值。</span></a></h1>
				</li>
					</br>

				<li id="nr_26" style="list-style:none;display:none">
				  <ul>
					<li>
					<div>
								 <textarea>
range创建数组

$a=range(0, 12);
$b=range(0, 100, 10);
$c=range('a', 'z');
echo "<pre>";
print_r($a);
print_r($b);
print_r($c);



一:字符串创建数组
$city  = "San Francisco";
$state = "CA";
$event = "SIGGRAPH";
$location_vars = array("city", "state");
$result = compact("event", "nothing_here", $location_vars);
在当前的符号表中查找该变量名并将它添加到输出的数组中，变量名成为键名而变量的内容成为该键的值。
print_r($result);
结果输出
Array
(
    [event] => SIGGRAPH
    [city] => San Francisco
    [state] => CA
)

二:数组创建数组
$arr=array(1=>"a",2=>"b",3=>"c");
//print_r($arr);
$arr2=array("d","e","f");
$arr3=array("arr","arr2");
$resut=compact($arr,$arr2,$arr3);
echo "<pre>";
print_r($resut);
结果输出:
Array
(
    [arr] => Array
        (
            [1] => a
            [2] => b
            [3] => c
        )

    [arr2] => Array
        (
            [0] => d
            [1] => e
            [2] => f
        )

)

以[]建立数组,且下标不为连续的数组创建数组
$arr2=array();
$arr2[0]="aa";
$arr2[2]="bb";
$arr2[4]="cc";
$arr3=array("arr","arr2");
$resut=compact($arr,$arr2,$arr3);
echo "<pre>";
print_r($resut);
结果输出:
Array
(
    [arr] => Array
        (
            [0] => a
            [1] => b
            [2] => c
            [3] => d
        )

    [arr2] => Array
        (
            [0] => aa
            [2] => bb
            [4] => cc
        )

)

下标不是数字的数组创建数组
$arr=array();
$arr["这是a"]="a";
$arr["这是b"]="b";
$arr["这是c"]="c";
$arr["这是d"]="d";
//print_r($arr);

$arr2=array();
$arr2["这是aa"]="aa";
$arr2["这是bb"]="bb";
$arr2["这是cc"]="cc";
$arr3=array("arr","arr2");
$resut=compact($arr,$arr2,$arr3);
echo "<pre>";
print_r($resut);
结果输出:
Array
(
    [arr] => Array
        (
            [这是a] => a
            [这是b] => b
            [这是c] => c
            [这是d] => d
        )

    [arr2] => Array
        (
            [这是aa] => aa
            [这是bb] => bb
            [这是cc] => cc
        )

)

多维数组的创建
$arr=array("a"=>"aa","bb",array("cc","d"=>"dd"));
$arr2=array("aaa","b"=>"bbb","c",array("d"=>"ddd","e"));
$arr3=array("arr","arr2");
$resut=compact($arr,$arr2,$arr3);
echo "<pre>";
print_r($resut);
结果输出:
Array
(
    [arr] => Array
        (
            [a] => aa
            [0] => bb
            [1] => Array
                (
                    [0] => cc
                    [d] => dd
                )

        )

    [arr2] => Array
        (
            [0] => aaa
            [b] => bbb
            [1] => c
            [2] => Array
                (
                    [d] => ddd
                    [0] => e
                )

        )

)




							</textarea>
						</div>
					</li>
				  </ul>
				</li>
						
																	


			    <li>
					<h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_17">is_array/unset/<font color=red>isset/empty</font>/count</a></h1>
				</li>
				</br>

				<li id="nr_17" style="display:none;">
                     <ul id="">
						<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_11">is_array  <span>义:检测变量是否是数组,如果 var 是 array，则返回 TRUE，否则返回 FALSE。</span></a></h1>
						</li>
						</br>
											
						<li id="de_11" style="list-style:none;display:none">
						  <ul>
							<li>
							<div>
								 <textarea>
  注:可以在做业务时对其所得的结果进行判定

  $a="";
  echo (is_array($a))?'true':'false';      //输出false
  echo "<br>";
  
  $b=array();
  echo (is_array($b))?'true':'false' ;           //输出true
  echo "<br>";
  
  $c=array("a","b",array("c","d"));
  echo (is_array($c))?'true':'false';       //输出true
  echo "<br>";
  
  $d=array("a"=>"a1","b"=>"b1","c"=>"c1");
  echo (is_array($c))?'true':'false';       //输出true



								 </textarea>
											</div>
										</li>
									</ul>
								</li>
											  
							
							<li>
								<h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_12">unset  <span>义:释放给定的变量</span></a></h1>
							</li></br>
											  
							<li id="de_12" style="list-style:none;display:none">
							  <ul>
								<li>
								<div>
								 <textarea>

$arr=array("a"=>"a1","b"=>"b1","c"=>"c1");
unset($arr["a"]); 
echo "<pre>";   
print_r($arr);            //打印出来的是缺少第一个元素值的数组

多维数组的unset应用
$arr=array("a"=>"a1","b"=>"b1","c"=>"c1","d"=>array("d1","e1","f1"));
unset($arr["d"][0]);
echo "<pre>";    
print_r($arr);             //打印出来的是什么?
注:unset()可以销毁多个变量,参数可以是多个
例如:
$array=array("aa","b"=>"bb","cc",array("dd","e"=>"ee"));
unset($array[0],$array["b"],$array[2][0]);
echo "<pre>";
print_r($array);
结果输出:


								 </textarea></div>
												</li>
											  </ul>
											</li>
											
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_13">count  <span>义:计算数组中的单元数目或对象中的属性个数。返回 var 中的单元数目，通常是一个 array，任何其它类型都只有一个单元</span></a></h1></li></br>
							<li id="de_13" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$a[0] = 1;
$a[1] = 3;
$a[2] = 5;
echo $result = count($a);
// $result == 3

$arr=array();
echo count($arr);  //输出值为0

echo count(null);  //输出为0

echo count(false);  //输出为1

多维数组的count
$arr=array(array("a","b","c"),"aa","bb","cc",array("aaa","bbb",array("ccc","ddd")));
echo count($arr)."<br>";     //输出为5
echo count($arr,COUNT_RECURSIVE);   //输出13,只要有多少元素,就统计多少,如果 mode 被设置为 COUNT_RECURSIVE（或 1），则会递归计算多维数组中的数组的元素个数,默认的是0
拓展:利用count函数来建立数组,理解与下标的关系
								 </textarea></div>
												</li>
											  </ul>
											</li>
											  
											  
											</ul>
											</li>
							  
			






<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_188"><span style="color:red">$_POST/$_GET/表单/超链接</a></h1></li></br>
<li id="nr_188" style="display:none;">
	<ul id=""><li>
		1.前端向后台传递参数，或者 客户端 向 服务端 传递参数，最常用通过$_POST和$_GET<br>
		2.是超全局变量。<br>
		3.举例<br><br>

								 <textarea>

Get将表单中数据的按照variable=value的形式，添加到action所指向的URL后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；
Post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL。

创建文件form.php,以get的方式进行数据的提交,提交页面指向get_post.php
<form action="get_post.php" method="get"> 
   姓名:<input type="text" name="name"><br><br>
   号码:<input type="text" name="tel"><br><br>
   性别:<input type="radio" name="sex" value="男生">男生
       <input type="radio" name="sex" value="女生">女生<br><br>
   <input type="submit" value="提交">
   <input type="reset" value="清空">
</form>

创建文件get_post.php,输出本框和单选框的值
<?php
  echo "姓名:".$_GET["name"]."<br>";
  echo "号码".$_GET["tel"]."<br>";
  echo "性别".$_GET["sex"]."<br>";
  

?>

创建文件form.php,以post的方式进行数据的提交,提交页面指向get_post.php
<form action="get_post.php" method="post"> 
   姓名:<input type="text" name="name"><br><br>
   号码:<input type="text" name="tel"><br><br>
   性别:<input type="radio" name="sex" value="男生">男生
       <input type="radio" name="sex" value="女生">女生<br><br>
   <input type="submit" value="提交">
   <input type="reset" value="清空">
</form>


创建文件get_post.php,输出本框和单选框的值
<?php
  echo "姓名:".$_POST["name"]."<br>";
  echo "号码".$_POST["tel"]."<br>";
  echo "性别".$_POST["sex"]."<br>";
  

?>

注:
1.判断是get/post提交,是看form表单中method是以get/post形式显示.
2.显示所提交的值,关键是找出表单标签的name值, 即echo $_GET["表单name的值"]或echo $_POST["表单name的值"].                                </textarea>
	</li></ul>
</li>


<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_189"><span style="color:red">递归/替换数组内容/return</a></h1></li></br>
<li id="nr_189" style="display:none;">
	<ul id=""><li>
		1.递归：从代码上看是自己调用自己。例如在一个函数内部，调用了函数自己<br>
		2.若某个问题，可分解成多个相同的小问题，且这些小问题的个数不可预计，使用递归<br>
		3.否则，使用循环<br>
		4.实际业务：<br>
			进行某目录和其子目录下的操作（检索/删除/拷贝）。具体案例将在文件函数说到<br>
			无限级分类操作（商品分类/新闻分类/自定义分类）。具体案例将在项目中说到<br><br>


案例：替换数组内容<br>
								 <textarea>

//失恋了，由爱生恨，要将房间一切记忆重置
//无论房间里有多少记忆，无论记忆存放在哪个旮旯里，都是要把“爱”变成“恨”

function test($arr,$search,$r)  {
	/* //调试代码
	static $n=0;

	$n++;
	if($n==1){
		$color="green";
		$case="房间";
	}else if($n==2){
		$color="blue";
		$case="写字台";
	}else if($n==3){
		$color="red";
		$case="抽屉";
	}
	echo "<font color=".$color.">第",$n,"次调用，传得数组内容如下：(好像打开一个".$case.")</font>";
	echo "<pre>";
	print_r($arr);
	echo "</pre>";
	echo "<br>";
	*/
	

	$new_arr=array();
	foreach($arr as $key=>$val){
		if(!is_array($val)){
			$new_arr[$key]=str_replace($search,$r,$arr[$key]);
		}else{
			$new_arr[$key]=test($val,$search,$r);
		}
	}

	return $new_arr;
}   

$a=array(
			'若,想念能开出一树花 忘记了多久, 我爱你我',
			100=>array(
						"天我爱你。今夜我想起了你，想起了过往，春的辜负，夏的热烈，秋的悲伤，放手爱你",
						array(
								'我要在你耳边呼吸，轻轻的述说，qiqi我爱你'
							)
						),
			'我爱你qiqi，你说你喜欢雪，因为相信一句，为和你白了头'
		);
$b='爱';
$c='恨';

echo "<pre>";
print_r(test($a,$b,$c));                            </textarea>
	</li></ul>
</li>



<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_18">in_array/array_key_exists/array_search</a></h1></li></br>
			
			<li id="nr_18" style="display:none;">
                                            <ul id="">
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_14">in_array  <span>义:检查数组中是否存在某个值,如果找到则返回 TRUE，否则返回 FALSE。</span></a></h1></li></br>
											  
											  <li id="de_14" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$arr=array("a","b","c","d");
if(in_array("a",$arr)){
  echo "恭喜,找到了";
}else{
  echo "抱歉,没找到";
}

输出:"恭喜,找到了"

$arr2=array("a","b",array("c","d"));
if(in_array("c",$arr2)){
  echo "恭喜,找到了";
}else{
  echo "抱歉,没找到";
}

上面的输出什么呢???

								 </textarea></div>
												</li>
											  </ul>
											</li>
											  
											  
											
									 		 <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_15">array_key_exists  <span>义:检查给定的键名或索引是否存在于数组中,在给定的 key 存在于数组中时返回 TRUE。key 可以是任何能作为数组索引的值。</span></a></h1></li></br>
											 
											  <li id="de_15" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$arr=array("one"=>"aaa","two"=>"bbb","three"=>"ccc");
if(array_key_exists("two",$arr)){                   
   echo "这个键值是存在的";
}else{
   echo "键值不存在哦";
}
输出:这个键值是存在的

多维数组的array_key_exists
$arr=array("one"=>"aaa","two"=>"bbb","three"=>"ccc",array("111"=>"hhh"));
//print_r($arr);
if(array_key_exists(???)){                   //我想找数组里键值为111的,括号里面怎么写???
   echo "这个键值是存在的";
}else{
   echo "键值不存在哦";
}

注意:
isset() 对于数组中为 NULL 的值不会返回 TRUE，而 array_key_exists() 会。
$search_array = array('first' => null, 'second' => 4);

// returns false
$a=isset($search_array['first']);
var_dump($a)."<br>";

// returns true
$b=array_key_exists('first', $search_array);
var_dump($b);

								 </textarea></div>
												</li>
											  </ul>
											</li>
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_16">array_search  <span>义:在数组中搜索给定的值，如果成功则返回相应的键名 </span></a></h1></li></br>
											  
											 <li id="de_16" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$array = array(0 => 'blue', 1 => 'red', 2 => 'green', 3 => 'red');

$key = array_search('red', $array);     
echo $key;      //输出值为1


								 </textarea></div>
												</li>
											  </ul>
											</li>  
											  
											</ul>
											</li>
				


			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_19">explode/implode/<font color=red>array_merge</font></a></h1></li></br>
			
			
			<li id="nr_19" style="display:none;">
                                            <ul id="">
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_17">explode  <span>义:使用一个字符串分割另一个字符串,此函数返回由字符串组成的数组，每个元素都是 string 的一个子串，它们被字符串 separator 作为边界点分割出来。</span></a></h1></li></br>
											
											 <li id="de_17" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$str = 'one|two|three|four';

// 正数 limit
print_r(explode('|', $str, 2));

输出:Array ( [0] => one [1] => two|three|four )
// 负数 limit (since PHP 5.1)  
print_r(explode('|', $str, -1));
输出:Array ( [0] => one [1] => two [2] => three ) 


								 </textarea></div>
												</li>
											  </ul>
											</li>  
											  
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_18">implode  <span>义:把数组元素组合为一个字符串。</span></a></h1></li></br>
											  
			<li id="de_18" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$array = array('lastname', 'email', 'phone');
$comma_separated = implode(",", $array);
echo $comma_separated; // 输出lastname,email,phone
涉及业务:在数据库中有分隔符分割的内容,根据业务需要将内容分别提取出来
								 </textarea></div>
												</li>
											  </ul>
											</li>  

											  
											</ul>
											</li>


			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_20">ksort/krsort asort/arsort/sort/rsort</a></h1></li></br>
			
			<li id="nr_20" style="display:none;">
                                            <ul id="">
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_19">ksort  <span>义:对数组按照键名排序，保留键名到数据的关联。本函数主要用于关联数组。</span></a></h1></li></br>
						  <li id="de_19" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$arr=array("a"=>"aaa","c"=>"ccc","b"=>"bbb","d"=>"ddd");
ksort($arr);
print_r($arr);      
 
$arr=array("0"=>"诺","2"=>"源","4"=>"T","1"=>"博","3"=>"I","6"=>"育","5"=>"教");
ksort($arr);
echo "<pre>";
print_r($arr);

								 </textarea></div>
												</li>
											  </ul>
											</li>  
				  
											  
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_20">krsort  <span>义:对数组按照键名逆向排序，保留键名到数据的关联。主要用于结合数组。 </span></a></h1></li></br>

			  <li id="de_20" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$fruits = array("d"=>"lemon", "a"=>"orange", "b"=>"banana", "c"=>"apple");
krsort($fruits);
foreach ($fruits as $key => $val) {       //循环遍历数组,下面将会讲到
    echo "$key = $val\n";
}

输出:
d = lemon
c = apple
b = banana
a = orange

								 </textarea></div>
												</li>
											  </ul>
											</li>
                                              <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_21">asort  <span>义:本函数对数组进行排序，数组的索引保持和单元的关联。主要用于对那些单元顺序很重要的结合数组进行排序。</span></a></h1></li></br>
								
									  <li id="de_21" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");
asort($fruits);
foreach ($fruits as $key => $val) {     //循环遍历数组,下面将会讲到
    echo "$key = $val\n";
}

输出:
c = apple
b = banana
d = lemon
a = orange

fruits 被按照字母顺序排序，并且单元的索引关系不变。

								 </textarea></div>
												</li>
											  </ul>
											</li>			  
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_22">arsort  <span>义:本函数对数组进行排序，数组的索引保持和单元的关联。主要用于对那些单元顺序很重要的结合数组进行排序。</span></a></h1></li></br>
										
																			  <li id="de_22" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");
arsort($fruits);
foreach ($fruits as $key => $val) {     //循环遍历数组,下面将会讲到
    echo "$key = $val\n";
}

输出:
a = orange
d = lemon
b = banana
c = apple

fruits 被按照字母顺序逆向排序，并且单元的索引关系不变。

								 </textarea></div>
												</li>
											  </ul>
											</li>		  
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_23">sort  <span>义:本函数对数组进行排序。当本函数结束时数组单元将被从最低到最高重新安排。 </span></a></h1></li></br>
							<li id="de_23" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$arr=array("a","c","d","b","e");
sort($arr);
foreach($arr as $key=>$val){
   echo $key."=".$val."<br>";
}

输出:
0=a
1=b
2=c
3=d
4=e

								 </textarea></div>
												</li>
											  </ul>
											</li>										  
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_24">rsort  <span>义:本函数对数组进行逆向排序（最高到最低）。</span></a></h1></li></br>
																						  
<li id="de_24" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$arr=array("a"=>"f","b"=>"e","c"=>"d");
rsort($arr);
print_r($arr);
输出:Array ( [0] => f [1] => e [2] => d )

								 </textarea></div>
												</li>
											  </ul>
											</li>												  
											</ul>
											</li>
											



			




			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_21">array_pop/array_push/array_shift/array_unshift</a></h1></li></br>
			
						<li id="nr_21" style="display:none;">
                                            <ul id="">
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_25">array_pop  <span>义:弹出并返回 array 数组的最后一个单元，并将数组 array 的长度减一。如果 array 为空（或者不是数组）将返回 NULL。</span></a></h1></li></br>
											  
						<li id="de_25" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$arr=array("java","c","c++","php");
array_pop($arr);
var_dump($arr);

								 </textarea></div>
												</li>
											  </ul>
											</li>												  
																  
											  
											  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_26">array_push  <span>义:将一个或多个单元压入数组的末尾（入栈） </span></a></h1></li></br>


						<li id="de_26" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
header("Content-Type: text/html; charset=utf-8"); //设置
$arr=array("欢迎","各位","来到");
array_push($arr,"诺博源科技","学习");
echo "<pre>";
print_r($arr);

								 </textarea></div>
												</li>
											  </ul>
											</li>
                                              <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_27">array_shift  <span>义:将数组开头的单元移出数组 </span></a></h1></li></br>
											
<li id="de_27" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$arr=array("欢迎","各位","来到");
$show=array_shift($arr);
echo ($show);        //可用于获取数组中的

								 </textarea></div>
												</li>
											  </ul>
											</li>  
							 				  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_28">array_unshift  <span>义:在数组开头插入一个或多个单元</span></a></h1></li></br>			  
									
		<li id="de_28" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
					
$queue = array("orange", "banana");
array_unshift($queue, "apple", "raspberry"); 

Array
(
    [0] => apple
    [1] => raspberry
    [2] => orange
    [3] => banana
			 



								 </textarea></div>
												</li>
											  </ul>
											</li>  
		  


											</ul>
											</li>




<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_22">list  <span>义:把数组中的值赋给一些变量,仅能用于数字索引的数组并假定数字索引从 0 开始。 </span></a></h1></li></br>
			
			<li id="nr_22" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$info = array('coffee', 'brown', 'caffeine');
// Listing all the variables
list($drink, $color, $power) = $info;
echo "$drink is $color and $power makes it special.\n";


$arr=array("小明","清华大学","博士");
list($name,$school,$education_background)=$arr;
echo "他是".$name.",现在在".$school."攻读".$education_background;
注:list() 从最右边一个参数开始赋值。如果你用单纯的变量，不用担心这一点。但是如果你用了具有索引的数组，通常你期望得到的结果和在 list() 中写的一样是从左到右的，但实际上不是。是以相反顺序赋值的。只响应数组的下标数字

业务上:比如在切割字符串为数组的时候,需要把数组值赋给变量进行输出,我们可以用list()函数完成;从数据库中快速取值赋给变量.

								 </textarea></div>
												</li>
											  </ul>
											</li>
							



				
			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_23">array_rand  <span>义:从数组中随机取出一个或多个单元。如果你只取出一个，array_rand() 返回一个随机单元的键名，否则就返回一个包含随机键名的数组。这样你就可以随机从数组中取出键名和值 </span></a></h1></li></br>
			
			<li id="nr_23" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$input = array("Neo", "Morpheus", "Trinity", "Cypher", "Tank");
$rand_keys = array_rand($input,4);
print_r($rand_keys);
业务:手机号码摇奖,将用户手机号存入数据库,把手机号提取出来作为用户得奖依据



								 </textarea></div>
												</li>
											  </ul>
											</li>
			


			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_24">array_unique  <span> 义:移除数组中重复的值 </span></a></h1></li></br>
			
			<li id="nr_24" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$input = array("a" => "green", "red", "b" => "green", "blue", "red");
//print_r($input);exit;
$result = array_unique($input);
print_r($result);

输出:Array ( [a] => green [0] => red [1] => blue ) 


								 </textarea></div>
												</li>
											  </ul>
											</li>






				<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_31">foreach  <span>义:遍历数组,注:foreach仅用于数组。</span></a></h1></li></br>
																						  
				<li id="de_31" style="list-style:none;display:none">
					  <ul>
						<li>
						<div>
								 <textarea>
								 
$arr = array("one", "two", "three");
foreach($arr as $value){
 echo "value=$value"."<br>";
}
输出:
value=one
value=two
value=three

reset($arr);     ???为什么要reset $arr
while(list($key,$value)=each($arr)){
   echo "$key:$value<br>";
}
输出:
0:one
1:two
2:three


								 </textarea>
							</div>
							</li>
						  </ul>
						</li>



			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_28">
array_flip/array_keys/array_values</a></h1></li></br>

        <li id="nr_28" style="display:none;">
                                            <ul id="">
											
			 <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_32">array_flip  <span>义:交换数组中的键和值.注:注意数组中的值需要能够作为合法的键名</span></a></h1></li></br>
			 
			 <li id="de_32" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$trans = array("a" =>"aaa", "b" =>"bbb", "c" =>"ccc");
$trans = array_flip($trans);
print_r($trans);
输出:Array ( [aaa] => a [bbb] => b [ccc] => c )



$arr=array("中国","美国","法国","中国","法国");
$result=array_flip($arr);      //将$arr中键值换为键名,并且保持键名的唯一性,如果一个值重复出现多次,则最后一个键名将作为它的值,其他的丢失了
echo "<pre>";
print_r($result);

  
$arr_new=array_unique($arr);     //去掉$arr_new中重复的值,并且只保留第一个单元的值
$show=array_flip($arr_new);     
print_r($show);

array_unique和array_flip的区别:
两者都可以取到唯一的键值;
前者取的是重复值中第一个单元的值,后者是将最后一个键名作为其值



 

								 </textarea></div>
												</li>
											  </ul>
											</li>
											 
											
			  <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_33">array_keys  <span>义:返回 input 数组中的数字或者字符串的键名。</span></a></h1></li></br>
			     
			  	 <li id="de_33" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$arr=array("a"=>"aaa","b","c"=>"ccc",array("d"=>"ddd","f"));
$arr=array_keys($arr);
echo "<pre>";
print_r($arr);
输出:
Array
(
    [0] => a
    [1] => 0
    [2] => c
    [3] => 1
)   
问:我想打印出下面的效果,怎么做???
Array                              
(
    [0] => d
    [1] => 0
)
								 </textarea></div>
												</li>
											  </ul>
											</li>
											
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_34">array_values  <span>义:返回数组中所有的值并给其建立数字索引。</span></a></h1></li></br>
			     
			  	 <li id="de_34" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$arr=array("a"=>"aaa","b","c"=>"ccc",array("d"=>"ddd","f"));
$arr=array_values($arr);
echo "<pre>";
print_r($arr);
输出:
Array
(
    [0] => aaa
    [1] => b
    [2] => ccc
    [3] => Array
        (
            [d] => ddd
            [0] => f
        )

)
								 </textarea></div>
												</li>
											  </ul>
											</li>
											
											  </ul>
											</li>
				




							
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_35">array_map  <span> 义:将回调函数作用到给定数组的单元上  </span></a></h1></li></br>
										<li id="nr_35" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

function math($num){
  return $num*$num*$num;
}		
$arr=array(1,3,5,7,9);
$arr=array_map("math",$arr);			
print_r($arr);
输出:
Array
(
    [0] => 1
    [1] => 27
    [2] => 125
    [3] => 343
    [4] => 729
) 


function math($num){
  return strip_tags(trim($num));   //返回的是去掉变量首尾端空格以及移除php和html标签的值
}   

$_GET=array_map("math",$_GET);   //$_GET所传的本身是个数组
echo "<pre>";
print_r($_GET);           //当在地址栏输入值时,显示所相应的数组


function math2(&$val,$key,$a){
 /* echo $key;
  echo "<br>";
  echo $a;*/
  $val=strip_tags(trim($val));
} 
array_walk (  $_GET , 'math2', 1234);    //array_walk()对数组中的每个成员应用用户函数
   
注:array_map和array_walk,都能进行回调函数到数组单元中去,但是参数的运用是有区别的


echo "<pre>";
print_r($_GET);                 //当在地址栏输入值时,显示所相应的数组

 

<?php
function test($content){
  return strip_tags(trim($content));
}
$_POST=array_map("test",$_POST);
echo "<pre>";
print_r($_POST);           //根据传过来的POST的值处理数组
?>
<html>
  <head>
  </head>
  <body>
    <form action="" method="post">
	   <input type="text" name="t1">
	   <input type="text" name="t2">
	   <input type="submit" value="提交">
	</form>
  </body>
</html>




								 </textarea></div>
												</li>
											  </ul>
											</li>  
										  




<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_36">array_diff/array_intersect  <span></span></a></h1></li></br>
										  
   <li id="nr_36" style="display:none;">
                                            <ul id="">
											
			 <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_35">array_diff  <span>义: 计算数组的差集,返回一个数组，该数组包括了所有在 array1 中但是不在任何其它参数数组中的值。注意键名保留不变。</span></a></h1></li></br>
			 
			 <li id="de_35" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$arr1=array("唱歌","跳舞","游泳");
$arr2=array("阅读","唱歌","游泳","运动");
$diff=array_diff($arr1,$arr2);
print_r($diff);
输出:
Array ( [1] => 跳舞 ) 
								 </textarea></div>
												</li>
											  </ul>
											</li>
			 <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_36">array_intersect  <span>义:计算数组的交集, 返回一个数组，该数组包含了所有在 array1 中也同时出现在所有其它参数数组中的值。注意键名保留不变。</span></a></h1></li></br>
			 
			 <li id="de_36" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

 $arr1=array("音乐","电影","体育","阅读");
$arr2=array("资讯","新闻","社会");
$result=array_merge($arr1,$arr2);
$sect1=array_intersect($arr1,$result);
$sect2=array_intersect($arr2,$result);
echo "<pre>";
print_r($result);
echo "======<br>";
print_r($sect1);
echo "======<br>";
print_r($sect2);

输出:
Array
(
    [0] => 音乐
    [1] => 电影
    [2] => 体育
    [3] => 阅读
    [4] => 资讯
    [5] => 新闻
    [6] => 社会
)
======
Array
(
    [0] => 音乐
    [1] => 电影
    [2] => 体育
    [3] => 阅读
)
======
Array
(
    [0] => 资讯
    [1] => 新闻
    [2] => 社会
)

								 </textarea></div>
												</li>
											  </ul>
											</li>
											
											
											  </ul>
											</li>
											 



<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_37">array_combine/array_fill/array_fill_keys <span></span></a></h1></li></br>
								<li id="nr_37" style="display:none;">
                                            <ul id="">											
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_37">array_combine  <span>义:创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值,array_combine ( array $keys , array $values )
返回一个 array，用来自 keys 数组的值作为键名，来自 values 数组的值作为相应的值。 
</span></a></h1></li></br>	
							
						<li id="de_37" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
$a = array('green', 'red', 'yellow');
$b = array('avocado', 'apple', 'banana');
$c = array_combine($a, $b);

print_r($c);

输出:
Array
(
    [green]  => avocado
    [red]    => apple
    [yellow] => banana
)
注意:如果两个数组的单元数不同或者数组为空时返回 FALSE。
								 </textarea></div>
												</li>
											  </ul>
											</li>	
					<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_38">array_fill  <span>义:用给定的值填充数组。array_fill ( int $start_index , int $num , mixed $value )用 value 参数的值将一个数组填充 num 个条目，键名由 start_index 参数指定的开始</span></a></h1></li></br>	
					
					<li id="de_38" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$arr=array("1"=>"a","2"=>"b");
$arr=array_fill(1,4,"欢迎");
echo "<pre>";
print_r($arr);
输出:
Array
(
    [1] => 欢迎
    [2] => 欢迎
    [3] => 欢迎
    [4] => 欢迎
)
								 </textarea></div>
												</li>
											  </ul>
											</li>	
					<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_39">array_fill_keys  <span>义:使用指定的键和值填充数组,array_fill_keys ( array $keys , mixed $value )
使用 value 参数的值作为值，使用 keys 数组的值作为键来填充一个数组。
</span></a></h1></li></br>			
					
					<li id="de_39" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$arr=array("这","里","是","诺","博","源");
$result=array_fill_keys($arr,"欢迎");
echo "<pre>";
print_r($result);
输出:
Array
(
    [这] => 欢迎
    [里] => 欢迎
    [是] => 欢迎
    [诺] => 欢迎
    [博] => 欢迎
    [源] => 欢迎
)

								 </textarea></div>
												</li>
											  </ul>
											</li>	
						
								            </ul>
											</li>	







			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_38">extract <span>义:从数组中将变量导入到当前的符号表,对于数组中的每个元素，键名用于变量名，键值用于变量值。</span></a></h1></li></br>	
			<li id="nr_38" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$a = 'Original';
$my_array = array("a" => "Cat","b" => "Dog", "c" => "Horse");
extract($my_array,EXTR_PREFIX_SAME, "wddx");
echo "\$a = $a; \$b = $b; \$c = $c";
输出:
$a = Original; $b = Dog; $c = Horse


function x($tpPath){
   ob_start();              为什么要用这个函数

   $aa=array(
        'a'=>123,
        'b'=>array(array('x'=>1),array('x'=>2),array('x'=>3)),
   );
   extract($aa);
   unset($aa);

   //print_r($b);
   //exit;
   require_once($tpPath);
   return ob_get_clean();
}

$c=x(dirname(__FILE__)."/tpl_index.html");
echo 55555;
echo "<br>";
echo $c;
exit;


								 </textarea></div>
												</li>
											  </ul>
											</li>
						


					
				 <li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_39">current/next/prev/end
 <span></span></a></h1></li></br>

<li id="nr_39" style="display:none;">
                                            <ul id="">	
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_40">current  <span>义:返回数组中的当前单元,每个数组中都有一个内部的指针指向它“当前的”单元，初始指向插入到数组中的第一个单元。 </span></a></h1></li></br>
<li id="de_40" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$transport = array('foot', 'bike', 'car', 'plane');
$mode = current($transport); 
echo $mode;
输出:
foot
								 </textarea></div>
												</li>
											  </ul>
											</li>	
			
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_41">next  <span>义:将数组中的内部指针向前移动一位,返回数组内部指针指向的下一个单元的值，或当没有更多单元时返回 FALSE。  </span></a></h1></li></br>		

<li id="de_41" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$transport = array('foot', 'bike', 'car', 'plane');
$mode = next($transport); 
echo $mode;
输出:
bike
								 </textarea></div>
												</li>
											  </ul>
											</li>	
	
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_42">prev  <span>义:将数组的内部指针倒回一位,返回数组内部指针指向的前一个单元的值，或当没有更多单元时返回 FALSE.</span></a></h1></li></br>	

	<li id="de_42" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$transport = array('foot', 'bike', 'car', 'plane');
echo $mode = next($transport);
echo $mode = prev($transport); 
输出:
bike   foot
								 </textarea></div>
												</li>
											  </ul>
											</li>		
	
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_43">end  <span>义:将数组的内部指针指向最后一个单元 ,end() 将 array 的内部指针移动到最后一个单元并返回其值。
</span></a></h1></li></br>			

<li id="de_43" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$transport = array('foot', 'bike', 'car', 'plane');
$mode = end($transport); 
echo $mode;
输出:
plane
								 </textarea></div>
												</li>
											  </ul>
											</li>	
				
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_44">综合运用<span>
</span></a></h1></li></br>		

<li id="de_44" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$transport = array('foot', 'bike', 'car', 'plane');
$mode = current($transport); // $mode = 'foot';
$mode = next($transport);    // $mode = 'bike';
$mode = next($transport);    // $mode = 'car';
$mode = prev($transport);    // $mode = 'bike';
$mode = end($transport);     // $mode = 'plane';
								 </textarea></div>
												</li>
											  </ul>
											</li>
											
								
																								
</ul>
</li>



<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_41">作业<span></span></a></h1></li></br>
<li id="nr_41" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
							 <textarea>
1.为以下函数注释	
function array_d(array & $arr){
settype($deep,'integer');//$deep=0;//echo $deep;exit;
foreach($arr as $key => $val){
$d=is_array($val)?array_d($val)+1:1;
$d>$deep && $deep = $d;
}

return $deep;
}
2.运用array_pop/array_push/array_shift/array_unshift 取文件后缀
3.array_diff/array_intersect   体现其相关性 朋友之间的兴趣爱好
4.利用count函数来建立数组,理解与下标的关系                      
5.有一个新部门id号和旧部门id号，相对应的数组 如下：
$deptIdN2O=array(
11=>array('0310'),
12=>array('0313'),
13=>array('0314','0262','0273','0280'),
14=>array('0219'),
21=>array('0397'),
22=>array('0381','0282','0292'),
23=>array('0360','0361','0263','0264','0265','0270','0271','0272'),
24=>array('0290','0296'),
25=>array('0283','0295','0291','0229','0299'),
26=>array('0784','0793','0294','0295'),
31=>array('0211'),
32=>array('0212'),
33=>array('0239','0298'),
34=>array('0249'),
35=>array('0259'),
);
现在要生成一个：以旧部门id号为键名，新部门id号为键值的一维数组
提示：可使用array_merge/ array_combine/ array_pad 相关函数
6.有以下门店
$a = array('801'=>'长江路店', '803'=>'望江路店', '805'=>'梅山路店');

每个门店有以下柜台
$b = array(1=>1, 2=>2, 3=>3);

每个柜台的销售额区间如下
$c = array(1=>'0--100', 2=>'100--200', 3=>'200--500');

想要初始化一个数组
如以下结构：
Array
(
    [801] => Array
        (
            [1] => Array
                (
                    [0--100] => 0
                    [100--200] => 0
                    [200--500] => 0
                )

            [2] => Array
                (
                    [0--100] => 0
                    [100--200] => 0
                    [200--500] => 0
                )

            [3] => Array
                (
                    [0--100] => 0
                    [100--200] => 0
                    [200--500] => 0
                )

        )

    [803] => Array
)
7.为以下算法注释
function bubbleSort($arr) {
	$arrCount=count($arr);         
	for ($i=0;$i<$arrCount;$i++){ 
		for ($ii=$arrCount-2;$ii>=$i;$ii--){
			if($arr[$ii+1]<$arr[$ii]){ 
				list($arr[$ii+1],$arr[$ii])=array($arr[$ii],$arr[$ii+1]);
			} 
		}
	}
	return $arr; 
}	
8.有a-z 26个字母，求：任意3个字母的所有组合的数量，其中要区分出正续的(如：abc)数量，倒序的(如：cba)数量，相同的（如：ccc）数量
9.写一个函数，可以把一个数组(可以是多维)，里面的某些字符，替换成其他内容
10.使用递归将字符串反转
11.将javascript案例中的javascript登陆和jquery_表单验证，增加form的action和method，并提交到一个php页面，并输出$_GET和$_POST
11.用中括号定义一个2维数组，用array定义一个三维数组
12.将一个三维数组的所有键名和键值，使用foreach输出
13.新建一个商品数组，每个商品包括：name/price/pic。循环该数组，并显示。要求每3个商品一行。每个商品至少要有2种html标签
14.使用2维或以上数组，将自己钱包的内容，表达出来
15.对多维数组排序。可按照键名或者键值，倒序或正序。使用递归



								 </textarea></div>
												</li>
											  </ul>
											</li>
											
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_55">答案<span></span></a></h1></li></br>	
			<li id="nr_55" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
							 <textarea>
1.为以下函数注释	
function array_d(array & $arr){
	settype($deep,'integer');//$deep=0;//echo $deep;exit;  //设置$deep为整型

	foreach($arr as $key => $val){               //循环遍历数组
		$d=is_array($val)?array_d($val)+1:1;    // 判定$val是否为数组,是的话该数组维度+1,否则为1.       
		$d>$deep && $deep = $d;       //$d大于$deep并把$deep的值赋给$d 
	}

	return $deep;
}


4.利用count函数来建立数组,理解与下标的关系
$arr[0]="赵";
$arr[1]="钱";
$arr[count($arr)]="孙";
$arr[count($arr)]="李";
echo "<pre>";   
print_r($arr);

                      
5.有一个新部门id号和旧部门id号
现在要生成一个：以旧部门id号为键名，新部门id号为键值的一维数组
提示：可使用array_merge/ array_combine/ array_pad 相关函数
$deptIdO2N=array();
foreach($deptIdN2O as $key=>$val){
 $deptIdO2N=array_merge($deptIdO2N,array_combine($val,array_pad(array(),count($val),$key)));
}


6.有以下门店
$a = array('801'=>'长江路店', '803'=>'望江路店', '805'=>'梅山路店');

每个门店有以下柜台
$b = array(1=>1, 2=>2, 3=>3);

每个柜台的销售额区间如下
$c = array(1=>'0--100', 2=>'100--200', 3=>'200--500');

想要初始化一个数组
$d=array_fill_keys(
     array_keys($a),
     array_fill_keys (
          array_keys($b),
          array_combine(
              array_values($c),
              array_fill(0,count($c),0)
            ) 
         )
     );
echo "<pre>";
print_r($d);


7.为以下算法注释(冒泡算法)
function bubbleSort($arr) {
	$arrCount=count($arr);                        
	for ($i=0;$i<$arrCount;$i++){                  //for循环
		for ($ii=$arrCount-2;$ii>=$i;$ii--){            //对数组下标进行for循环
			if($arr[$ii+1]<$arr[$ii]){                     //判定如果数组下标大的值比数组下标下的邻近的值要小
				list($arr[$ii+1],$arr[$ii])=array($arr[$ii],$arr[$ii+1]);        //将值进行互换
			} 
		}
	}
	return $arr; 
}	


8.有a-z 26个字母，求：任意3个字母的所有组合的数量，其中要区分出正续的(如：abc)数量，倒序的(如：cba)数量，相同的（如：ccc）数量
$a=range("a","z");
$num=0;
$numasc=0;
$numdesc=0;
$numsame=0;

for($i=0;$i<26;$i++){
	$b=$a[$i];
	for($j=0;$j<26;$j++){
	  $c=$a[$j];
	  for($k=0;$k<26;$k++){
		  $d=$a[$k];
		  $num++;
		  
		  if($i==$j && $j==$k){
			 $numsame++; 
		  }else if($i-$j==1 &&$j-$k==1){
			 $numasc++; 
		  }else if($k-$j==1 && $j-$i==1){
			 $numdesc++;
		  }
		  $arr=array($b,$c,$d);
	  }
	}
}
echo $num."<br>";
echo $numasc."<br>";
echo $numdesc."<br>";
echo $numsame."<br>";


9.写一个函数，可以把一个数组(可以是多维)，里面的某些字符，替换成其他内容
function test($arr,$search,$r)  {  
	$new_arr=array();
	foreach($arr as $key=>$val){
		if(!is_array($val)){
			$new_arr[$key]=str_replace($search,$r,$arr[$key]);
		}else{
			$new_arr[$key]=test($val,$search,$r);
		}
	}

	return $new_arr;
}   

$a=array('我是谁a',100=>array("天ab",array('qiqia')),'abc');
$b='a';
$c='A';
print_r(test($a,$b,$c));  

10.使用递归将字符串反转

//不带调试说明的函数
function dg($str,$code){
	//static $s="";//可使用 静态变量

	$strlen=mb_strlen($str,$code);

	if($strlen>0){
		/* 若使用 静态变量
		$s=mb_substr($str,0,1,$code).$s;
		dg(mb_substr($str,1,mb_strlen($str,$code),$code),$code);
		return $s;
		*/
		return dg(mb_substr($str,1,mb_strlen($str,$code),$code),$code).mb_substr($str,0,1,$code);
	}
}

$st="自己定1义错2误a日志中";
echo dg($st,"utf-8");



//带调试说明的函数

function dg($str,$code,$i=0){
	$i++;//调试代码，增加次数

	echo str_repeat("&nbsp;&nbsp;",$i),"<font style='background:yellow'>第 ",$i,"次 调用</font>";//调试代码


	$strlen=mb_strlen($str,$code);//获得字符串长度

	if($strlen>0){//若长度大于0

		$x=mb_substr($str,0,1,$code);//截取第1个字符
		$y=mb_substr($str,1,$strlen,$code);//截取第1个字符后的字符

		echo " => ","<font style='background:green'>",$x,"</font>";
		echo " -- ","<font color=green>",$y,"</font><br>";

		$z=dg($y,$code,$i);//递归调用自己
		//这时，下面代码还没有执行，当前进程，就进入另外一个函数(自己)了，
		//所以，上面的调试代码全部先输出

		//下面调试代码实际是，上1次调用自己，结束时
		//结束时：就是有返回值，或函数结束
		//才能输出下面调试代码
		echo (!empty($z)?"":"<br>"),str_repeat("&nbsp;&nbsp;",$i),"第",$i,"次调用，第",$i+1,"次返回";
		echo "++>","<font color=blue>",$z,"</font>";
		echo "+++","<font style='background:green'>",$x,"</font><br>";


		return $z.$x;
	}
}

$st="一二三四五六";

$a=dg($st,"utf-8");


echo "<br>";
echo "<br>";
echo "<br>";

echo $a;


								 </textarea></div>
												</li>
											  </ul>
										</li>
					

		</ul>
	</li>
</div></br>
	<div id="bio">
			<li class="title_white_r" id="st_3" ><h1><a href="###" style="cursor:point;text-decoration:none;">第三部分 文件处理函数</a></h1></li>
			<li id="tc_3" style="list-style:none;display:none"></br>
			<ul id="">
							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_40">basename/dirname/pathinfo/realpath</a></h1></li></br>
							<li id="nr_40" style="display:none;">
                                            <ul id="">	
						<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_45">basename<span>义:给出一个包含有指向一个文件的全路径的字符串，本函数返回基本的文件名。
</span></a></h1></li></br>		

		<li id="de_45" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$path = "/home/httpd/html/index.php";
$file = basename($path);       
$file = basename($path,".php");
echo  $file;
输出  index


$file = 'image.jpg';
$info = pathinfo($file);
$file_name =  basename($file,'.'.$info['extension']);
echo $file_name;
输出 image

支持中文的
preg_replace('/^.+[\\\\\\/]/', '',$file);
								 </textarea></div>
												</li>
											  </ul>
											</li>
										<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_46">dirname<span>义:给出一个包含有指向一个文件的全路径的字符串，本函数返回去掉文件名后的目录名.
</span></a></h1></li></br>	

<li id="de_46" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$path="/wamp/www/teach/test.php";
echo "目录名为:".dirname($path);
输出:
/wamp/www/teach
								 </textarea></div>
												</li>
											  </ul>
											</li>
		
		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_47">pathinfo  <span>义:返回一个关联数组包含有 path 的信息。包括以下的数组单元：dirname，basename 和 extension。
</span></a></h1></li></br>	

<li id="de_47" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$path_parts = pathinfo("/www/htdocs/index.html");
echo $path_parts["dirname"] . "\n";
echo $path_parts["basename"] . "\n";
echo $path_parts["extension"] . "\n";

输出:
/www/htdocs
index.html
html
			                     </textarea></div>
												</li>
											  </ul>
											</li>
											
											                   
				 
						<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_65">realpath<span>义: 返回规范化的绝对路径名。
</span></a></h1></li></br>		

		<li id="de_65" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

echo realpath("file/info.txt");
输出:D:\wamp\www\teach\file\info.txt
echo "<br>";
该函数删除所有符号连接（比如 '/./', '/../' 以及多余的 '/'），返回绝对路径名。
echo realpath("./file");
输出:D:\wamp\www\teach\file
								 </textarea></div>
												</li>
											  </ul>
											</li>											   
											</ul>
											</li>
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_43">file_put_contents/file_get_contents</a></h1></li></br>
							<li id="nr_43" style="display:none;">
                                            <ul id="">	
						<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_48">file_put_contents  <span>义:将一个字符串写入文件.该函数将返回写入到文件内数据的字节数，失败时返回FALSE </span></a></h1></li></br>	
						<li id="de_48" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$file=dirname(__FILE__).'/file/content.txt';
$content="你好,诺博源\n";
echo file_put_contents($file,$content,FILE_APPEND );      //如果加上FILE_APPEND表示追加,不加则视为重置
echo "<pre>";
print_r(file(dirname(__FILE__).'/file/content.txt'));

echo "<br>";
$file2=dirname(__FILE__).'/file/content2.txt';
$content2="这是我新增加的内容\n";
echo file_put_contents($file2,$content2,LOCK_EX);      //当加上LOCK_EX进行了锁定后,不能进行内容的追加,而是重置内容
print_r(file(dirname(__FILE__).'/file/content2.txt'));   

$file3=dirname(__FILE__).'/file/content3.txt';
$content3="你好,诺博源\n";
echo file_put_contents($file3,$content3);      //不加后表示重置内容
print_r(file(dirname(__FILE__).'/file/content3.txt')); 


			                     </textarea></div>
												</li>
											  </ul>
											</li>
											
						

<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_49">file_get_contents<span>义:将整个文件读入一个字符串.该函数将返回读取到文件内数据，失败时返回FALSE .注意与file()的区别,file把文件读入为数组,而这个则是读入为一个字符串.
</span></a></h1></li></br>	

<li id="de_49" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$homepage = file_get_contents(dirname(__FILE__)."/html/baidu.html");
echo $homepage;       //输出baidu.html内容
$text=file_get_contents(dirname(__FILE__)."/file/info.txt");
echo $text;        //输出info.txt内容



			                     </textarea></div>
												</li>
											  </ul>
											</li>


                                       </ul>
									   </li>
									   				<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_44">fopen/fgets/fread/fwrite/fcolse</a></h1></li></br>
							<li id="nr_44" style="display:none;">
                                            <ul id="">	
				<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_51">fopen<span>义:打开文件或者 URL.
</span></a></h1></li></br>	
<li id="de_51" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
说明:
'r'     只读方式打开，将文件指针指向文件头。
'r+'    读写方式打开，将文件指针指向文件头。  
'w'     写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。  (重置文件内容)  
'w+'    读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。   (重置文件内容)  
'a'     写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。                 (追加内容)
'a+'    读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。                  (追加内容)
'x'     创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING级别的错误信息。如果文件不存在则尝试创建之。这和给 底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。此选项被        PHP 4.3.2 以及以后的版本所支持，仅能用于本地文件。
  
'x+'    创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给 底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。此选项被        PHP 4.3.2 以及以后的版本所支持，仅能用于本地文件。  


以只读的方式打开文件
$file=dirname(__FILE__)."/file/info.txt";
$fp=fopen($file,"r");
$write=fwrite($fp,"1111");
if($write){
  echo "将内容成功写入文件";
}else{
  echo "写入文件失败";
}
输出写入文件失败,那是因为打开文件的方式是只读

以读写的方式打开文件
$file2=dirname(__FILE__)."/file/info.txt";
$fp2=fopen($file2,"r+");
$write2=fwrite($fp2,"hello world 你好,世界");
if($write2){
  echo "将内容成功写入文件";
}else{
  echo "写入文件失败";
}
输出将内容成功写入文件,因为r+将文件指针指向文件头,所以文本中前面的内容将被替换

			                     </textarea></div>
												</li>
											  </ul>
											</li>

<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_52">fgets<span>义:从文件指针中读取一行.
</span></a></h1></li></br>	
<li id="de_52" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
读取文件一行内容					
$handle = fopen(dirname(__FILE__)."/file/123.txt", "r");
	$buffer=fgets($handle,4096);
	echo $buffer;
    fclose($handle);
输出:123 

逐行读取文件内容
$handle = fopen(dirname(__FILE__)."/file/123.txt", "r");
if ($handle) {
    while (!feof($handle)) {               //feof:测试文件指针是否到了文件结束的位置
        $buffer = fgets($handle, 4096);
        echo $buffer;
    }
    fclose($handle);
}
输出:
123 123 123 123 123\ 123 


			                     </textarea></div>
												</li>
											  </ul>
											</li>

<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_53">fread<span>义:读取文件.
</span></a></h1></li></br>	

<li id="de_53" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$filename = "file/info.txt";
$handle = fopen($filename, "r");
$contents = fread($handle, filesize ($filename));
echo $contents;
fclose($handle);
输出的是文本的内容


			                     </textarea></div>
												</li>
											  </ul>
											</li>
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_54">fwrite<span>义:写入文件
</span></a></h1></li></br>	
<li id="de_54" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$txt="file/mywrite.txt";
$content="这是我写的一些东西\n";
$info=fopen($txt,"a");
$showinfo=fwrite($info,$content);

fclose($info);
将$content里面的内容加入到文件里

			                     </textarea></div>
												</li>
											  </ul>
											</li>
	
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_55">fcolse<span>义:关闭一个已打开的文件指针.注:将 handle 指向的文件关闭。 成功时返回 TRUE， 或者在失败时返回 FALSE. 文件指针必须有效，并且是通过 fopen() 或fsockopen() 成功打开的。 

</span></a></h1></li></br>	

<li id="de_55" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$handle = fopen('file/123.txt', 'r');
fclose($handle);

			                     </textarea></div>
												</li>
											  </ul>
											</li>
																	
</ul>
</li>	
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_45">filesize  <span>义:取得文件大小,返回文件大小的字节数，如果出错返回 FALSE 并生成一条 E_WARNING 级的错误</span></a></h1></li></br>
									
									<li id="nr_45" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

$info="file/info.txt";
$filename=explode("/",$info);
//print_r($filename);exit;
echo $filename[1]."有:".filesize($info)."字节";

			                     </textarea></div>
								</li>
								</ul>
								</li>
											    
		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_46">is_dir/is_file/file_exists <span></span></a></h1></li></br>	
		<li id="nr_46" style="display:none;">
                                            <ul id="">
		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_56">is_dir<span>义:判断给定文件名是否是一个目录,如果文件名存在并且为目录则返回 TRUE。如果 filename 是一个相对路径，则按照当前工作目录检查其相对路径。
</span></a></h1></li></br>

<li id="de_56" style="list-style:none;display:none">
											  <ul>
											    <li>
											    	<ul>
												<div>
								 <textarea>

$dirtxt="mytxt.txt";
if(!is_dir($dirtxt)){
  echo "目录找不到或不存在";
}else{
  echo "目录找到了!";
}
输出:
目录找不到或不存在

			                     </textarea></div>
												
											  </ul>
											</li>
										</ul>
									</li>

<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_57">is_file<span>义:判断给定文件名是否为一个正常的文件,如果文件存在且为正常的文件则返回 TRUE。 

</span></a></h1></li></br>

<li id="de_57" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 

$text="file/info.txt";
if(is_file($text)){
 $content=fopen($text,"r");
 $info=fgets($content);
 echo $info;
 fclose($content);
}else{
 echo "这不是一个正常的文件";
}

输出文本内容

			                     </textarea></div>
												</li>
											  </ul>
											</li>

			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_64">file_exists<span>义:检查文件或目录是否存在 

</span></a></h1></li></br>

<li id="de_64" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
//判断文件是否存在
$filename = dirname(__FILE__).'/file/info.txt';

if (file_exists($filename)) {
    echo "The file $filename exists";
} else {
    echo "The file $filename does not exist";
}
//输出存在此文件路径信息


//判定目录是否存在
$dirpath=dirname(__FILE__)."/file";
if(file_exists($dirpath)){
  echo "此路径存在";
}else{
  echo "该路径不存在";
}
			                     </textarea></div>
												</li>
											  </ul>
											</li>						
											</ul>
											</li>						   
											
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_42">file  <span>义:把整个文件读入一个数组中</span></a></h1></li></br>
											<li id="nr_42" style="display:none;">
                                            <ul id="">
                                            	<li>
                                            		<div>
										<textarea>

$lines = file('http://www.baidu.com/');
// 在数组中循环，显示 HTML 的源文件并加上行号。
foreach ($lines as $line_num => $line) {
    echo "Line <b>{$line_num}</b> : " . htmlspecialchars($line) . "<br />\n";
}

输出百度源代码
$html = implode('', file ('http://www.baidu.com/'));
echo $html;


$trimmed = file('file/123.txt', FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
//FILE_IGNORE_NEW_LINES表示在每个数组单元后面忽略新行
//FILE_SKIP_EMPTY_LINES表示跳过空行
echo "<pre>";
 print_r ($trimmed);
 打印出:
 Array
(
    [0] => 123
    [1] => 123  
    [2] => 456
    [3] => 123
    [4] => 123\
    [5] => 123
)
 
			             </textarea>
			         </div>	</li>
											</ul>
											</li>
								<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_47"><font color=red>glob(opendir)</font>/mkdir/copy/unlink/rmdir<span></span></a></h1></li></br>	
						<li id="nr_47" style="display:none;">
                                            <ul id="">
		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_58">mkdir<span>义:新建目录,成功时返回 TRUE， 或者在失败时返回 FALSE. 
</span></a></h1></li></br>

<li id="de_58" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

//在当前文件夹下，创建testFile文件夹
if(mkdir(dirname(__FILE__)."/testFile",0700)){          //注意:默认的 mode 是 0777，意味着最大可能的访问权。
echo "目录路径创建成功";
}else{
echo "目录路径创建失败";
}
//第一次运行该代码时,目录会创建成功,第二次运行时显示warming,表示该目录已存在.



//递归创建多级目录，第3个参数为true
if (!@mkdir(dirname(__FILE__)."/testFile2/test",0777,true)) {
    die('Failed to create folders...');
}

//或者用函数
//递归创建多级目录
    function createTree($dir){  
      
        if(file_exists($dir)){  
            return ;  
        }  
        if(!is_dir(dirname($dir))){  
              
                    createTree(dirname($dir));  
        }  
            mkdir($dir);  
      
            return;  
    }  
      
    //createTree(dirname(__FILE__).'/e/d');
								 


			                     </textarea></div>
												</li>
											  </ul>
											</li>
		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_59">copy<span>义:拷贝文件,bool copy ( string $source , string $dest )将文件从 source 拷贝到 dest。成功时返回 TRUE， 或者在失败时返回 FALSE. 

</span></a></h1></li></br>

<li id="de_59" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$file = 'file/info.txt';
$newfile = 'file/info.txt.bak';

if (!copy($file, $newfile)) {
    echo "failed to copy $file...\n";
}else{
    echo "copy success";
}

输出:copy success,表示文件以成功拷贝
								 


			                     </textarea></div>
												</li>
											  </ul>
											</li>
		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_60">unlink<span>义:删除文件,bool unlink ( string $filename ),成功时返回 TRUE， 或者在失败时返回 FALSE. 
</span></a></h1></li></br>

<li id="de_60" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$fh = fopen('file/test.html', 'a');     //以写入的方式打开
fwrite($fh, '<h1><a href="http://www.baidu.com">百度一下,你就知道</h1></a>');   //写入内容
fclose($fh);
//以上可以成功写入内容,并可以用浏览器打开
unlink('file/test.html');
//unlink之后,该html文件不存在
								 


			                     </textarea></div>
												</li>
											  </ul>
											</li>
		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_61">rmdir <span>义:删除目录,bool rmdir ( string $dirname ),注意:该目录必须是空的，而且要有相应的权限。成功时返回 TRUE， 或者在失败时返回 FALSE. 
</span></a></h1></li></br>
  
  <li id="de_61" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
if(!is_dir("file/123/")){
  mkdir("file/123/",0700);           //创建目录
  $file="file/info.txt";              
  $copyfile="file/123/info.txt.bak";
  copy($file,$copyfile);              //复制文件到该目录下
  if(rmdir("file/123/")){           
     echo "操作成功";
  }else{
     echo "操作失败";               //由于rmdir函数要求该目录下必须为空,所以输出操作失败,并显示warming,说明该目录不为空
	 mkdir("file/456/",0700);      //重新创建目录
	 rmdir("file/456/");           //删除目录,由于该目录下没内容,所以输出删除目录成功
	 echo "删除目录成功";           
  }
}
								 


			                     </textarea></div>
												</li>
											  </ul>
											</li>

                      </ul>	
					  </li>				

							<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_1333"><font color=red>filectime/filemtime/touch/disk_total_space/disk_free_space/chdir/getcwd</font>  <span>
														</span></a></h1></li></br>
														<li id="nr_1333" style="display:none">
														  <ul>
														  <li>
														  <div>
															 <textarea>
															 </textarea></div>
														  </li>
														  </ul>
														</li>
							
				<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_49">作业<span></span></a></h1></li></br>	
			<li id="nr_49" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
							 <textarea>

1.计数器：
(1)写一个基本功能的文本计数器程序(显示/累加/保存)：这个程序肯定是以函数形式存在的
(2)用户(来源)分析
2.每天，当用户提交搜索的时候(可以以$search_word=”八卦”;表示)，有一个程序会将当天所有搜索的词汇保存起来。到每天晚上，有一个程序会将当天所有词汇汇总，并且统计次数，并且和昨天的汇总比较，取前100个最大搜索量的词组，然后保存起来。完成以上的需求.
3.有一个文本，保存了当前的销售信息。示例如下：
销售时间|商品名称|商品类型|销售个数|销售单价|发票号
01:01:01|商品A|服装|12|120|3344
12:59:59|商品b|电器|2|1200|5566
11:11:1|商品c|黄金|2|4500|5566

写函数：统计当天所有商品销售量排名
写函数：统计当天每个时间段内(以小时)，商品销售总价排名
写函数：计算哪个时间段内(以小时)，销售的商品中，销售总价最低的，但要排除电器类型和黄金类型的，并且不同的发票号要有3个以上。最终输出类似以下内容：”亲爱的顾客您好！昨日13-14点间凡在我商场购买的商品都将半价返还给顾客，其中持有以下发票号的用户：001/002/003，作为中奖用户，我们将全额返回！请尊敬的客户携带相应发票到商场客服中心办理”
4.不使用tempnam在某目录下创建一个不会重名的文件夹
5.拷贝某目录下所有后缀rar文件（包含中文名，空格），到另外一个目录。不需要包含子目录
6.拷贝某目录下所有后缀rar文件（包含中文名，空格），到另外一个新目录。需要包含子目录
7.删除一个含有文件的目录，包括子目录
8.glob递归查找所指定文件(子文件夹)下的所有文件	
9.编写一个资源管理器,要求:找出所以指定文件下的所有文件及文件的大小(//要用到$_GET,可提前说,或者以后作业)
10.取文件后缀,用文件处理函数							 
</textarea></div>
												</li>
											  </ul>
											</li>	
											
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_56">部分答案<span></span></a></h1></li></br>	
			<li id="nr_56" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
							 <textarea>

1.计数器：
(1)写一个基本功能的文本计数器程序(显示/累加/保存)：这个程序肯定是以函数形式存在的
function view($path){
  $fp=fopen($path,"r");
  $get=file_get_contents($path);
  //echo $get;
  fclose($fp);
  $fp=fopen($path,"w");
  $to_write=fwrite($fp,++$get);
  $count=file_get_contents($path);
 
    echo "这是第".$get."位访客进行了浏览";

}
view(dirname(__FILE__)."/file/viewcount.txt");
(2)用户(来源)分析
function wcount(){
  $path=dirname(__FILE__)."/wcount";

  $HTTP_REFERER=!empty($_SERVER['HTTP_REFERER'])?$_SERVER['HTTP_REFERER']:'';

  $val=date("Y-m-d H:i:s")."|".$_SERVER['REMOTE_ADDR']."|".$_SERVER['HTTP_USER_AGENT']."|".$_SERVER['REQUEST_URI']."|".$HTTP_REFERER."\n";
  file_put_contents($path,$val, FILE_APPEND | LOCK_EX);
}

function rcount(){
  $path=dirname(__FILE__)."/wcount";
  $r_n=array();
  $r_y=array();
  foreach(file($path,FILE_IGNORE_NEW_LINES |FILE_SKIP_EMPTY_LINES ) as $val){
      $val_t=explode('|',$val);

      if(empty($val_t[4])){
        empty($r_n[$val_t[3]]) && $r_n[$val_t[3]]=0;
        $r_n[$val_t[3]]++;
      }else{

        empty($r_y[$val_t[4]]) && $r_y[$val_t[4]]=0;
        $r_y[$val_t[4]]++;
      }
  }

  return array($r_n,$r_y);

}

wcount();

echo "<pre>";
print_r(rcount());

exit;
echo "<pre>";
print_r($_SERVER);

echo "<a href='./file.php?id=1&id2=3'>aaaaa</a>";


2.每天，当用户提交搜索的时候(可以以$search_word=”八卦”;表示)，有一个程序会将当天所有搜索的词汇保存起来。到每天晚上，有一个程序会将当天所有词汇汇总，并且统计次数，并且和昨天的汇总比较，取前100个最大搜索量的词组，然后保存起来。完成以上的需求.
function saveSearch($str,$saveDir){
  $savePath=$saveDir."/".date("Y-m-d");
  file_put_contents($savePath,$str."\n", FILE_APPEND | LOCK_EX);
}

function counts($saveDir){
  $savePath=$saveDir."/".date("Y-m-d");

  $searchWords=array_count_values(file($savePath,FILE_IGNORE_NEW_LINES |FILE_SKIP_EMPTY_LINES ));
  
  $searchWords100_path=$saveDir."/searchWords100";
  if(!is_file($searchWords100_path)){
    $searchWords100=array();
  }else{
    $searchWords100=array();
    foreach(file($searchWords100_path,FILE_IGNORE_NEW_LINES |FILE_SKIP_EMPTY_LINES ) as $val){
        $val_t=explode('|',$val);

        if(!empty($searchWords[$val_t[0]])){
            $searchWords[$val_t[0]]+=$val_t[1];
        }else{
            $searchWords[$val_t[0]]=$val_t[1];
        }
        
    }
  }
  arsort($searchWords);

  $rVal=array();
  $saveVal="";
  $i=0;
  foreach($searchWords as $key=>$val){
      $i++;
      if($i>=100){
        break;
      }
      $saveVal.=$key.'|'.$val."\n";

      $rVal[$key]=$val;
  }


  file_put_contents($searchWords100_path,$saveVal);

  return $rVal;


}

$d=dirname(__FILE__);
saveSearch('a',$d);
saveSearch('a',$d);
saveSearch('b',$d);
saveSearch('b',$d);
saveSearch('c',$d);
saveSearch('c',$d);
saveSearch('b',$d);

print_r(counts($d));


3.有一个文本，保存了当前的销售信息。示例如下：
销售时间|商品名称|商品类型|销售个数|销售单价|发票号
01:01:01|商品A|服装|12|120|3344
12:59:59|商品b|电器|2|1200|5566
11:11:1|商品c|黄金|2|4500|5566

写函数：统计当天所有商品销售量排名
写函数：统计当天每个时间段内(以小时)，商品销售总价排名
写函数：计算哪个时间段内(以小时)，销售的商品中，销售总价最低的，但要排除电器类型和黄金类型的，并且不同的发票号要有3个以上。最终输出类似以下内容：”亲爱的顾客您好！昨日13-14点间凡在我商场购买的商品都将半价返还给顾客，其中持有以下发票号的用户：001/002/003，作为中奖用户，我们将全额返回！请尊敬的客户携带相应发票到商场客服中心办理”

function stat_1($filePath){
	$dataArr=file($filePath);
	array_shift($dataArr);
	foreach($dataArr as $key=>$val){
		$val=rtrim($val,"\n\r");
		$dataArr[$key]=explode("|",$val);
	}
	return $dataArr;
}

function stat_2(array &$dataArr){
	$nArr=array();
	foreach($dataArr as $val){
		$nArr[$val[1]]=empty($nArr[$val[1]])?$val[3]:$nArr[$val[1]]+$val[3];
	}

	arsort($nArr);
	return $nArr;
}

function stat_3(array &$dataArr){
	/*
	$timeArray=array(
					  array('00:00:00','00:59:59'),	
					  array('01:00:00','01:59:59'),	
					  array('02:00:00','02:59:59'),	
					  array('03:00:00','03:59:59'),	
					  array('04:00:00','04:59:59'),	
					  array('05:00:00','05:59:59'),	
					  array('06:00:00','06:59:59'),	
					  array('07:00:00','07:59:59'),	
					  array('08:00:00','08:59:59'),	
					  array('09:00:00','09:59:59'),	
					  array('10:00:00','10:59:59'),	
					  array('11:00:00','11:59:59'),	
					  array('12:00:00','12:59:59'),	
					  array('13:00:00','13:59:59'),	
					  array('14:00:00','14:59:59'),	
					  array('15:00:00','15:59:59'),	
					  array('16:00:00','16:59:59'),	
					  array('17:00:00','17:59:59'),	
					  array('18:00:00','18:59:59'),	
					  array('19:00:00','19:59:59'),	
					  array('20:00:00','20:59:59'),	
					  array('21:00:00','21:59:59'),	
					  array('22:00:00','22:59:59'),	
					  array('23:00:00','23:59:59'),	
	);
	*/

	for($i=0;$i<=23;$i++) {
		$H=strlen($i)==1?'0'.$i:$i;
		$timeArray[]=array($H.':00:00',$H.':59:59');
		$nArr[]=0;
	}

	foreach($dataArr as $val){
		foreach($timeArray as $key2=>$val2){
			if($val[0]>=$val2[0] && $val[0]<=$val2[1]){
				$nArr[$key2]+=$val[3]*$val[4];
				break;
			}
		}
	}

	arsort($nArr);
	return $nArr;
}

function stat_4(array &$dataArr){
	for($i=0;$i<=23;$i++) {
		$H=strlen($i)==1?'0'.$i:$i;
		$timeArray[]=array($H.':00:00',$H.':59:59');
		$nArr[]=0;
		$n_fp_Arr[]=array();
	}

	foreach($dataArr as $val){
		foreach($timeArray as $key2=>$val2){
			if($val[2]!='电器' && $val[2]!='黄金'){
				if($val[0]>=$val2[0] && $val[0]<=$val2[1]){
					$nArr[$key2]+=$val[3]*$val[4];
					$n_fp_Arr[$key2][]=$val[5];
					break;
				}
			}else{
				break;
			}
		}
	}

	asort($nArr);

	//print_r($nArr);
	//print_r($n_fp_Arr);

	foreach($nArr as $key=>$val){
		if(count(array_unique($n_fp_Arr[$key]))>=3){
			$fp_keys=array_rand($n_fp_Arr[$key],3);
			return array($key,array($n_fp_Arr[$key][$fp_keys[0]],$n_fp_Arr[$key][$fp_keys[1]],$n_fp_Arr[$key][$fp_keys[2]] ) );
		}
	}

}

print_r($dataArray=stat_1(dirname(__FILE__)."/d"));

print_r(stat_2($dataArray));

print_r(stat_3($dataArray));

//print_r(stat_4($dataArray));
list($time_h,$fps)=stat_4($dataArray);

echo "”亲爱的顾客您好！昨日".$time_h."-".($time_h+1)."点间凡在我商场购买的商品都将半价返还给顾客，其中持有以下发票号的用户：".implode("/",$fps)."，作为中奖用户，我们将全额返回！请尊敬的客户携带相应发票到商场客服中心办理”";


4.不使用tempnam在某目录下创建一个不会重名的文件夹
function filepath($dir){
$new_dir=$dir.'/t';

while(is_dir($new_dir)){
	$new_dir=$new_dir.'t';
}

 mkdir($new_dir,0777);

return $new_dir;
}
 filepath(dirname(__FILE__)."/file/");
 
 
5.拷贝某目录下所有后缀rar文件（包含中文名，空格），到另外一个目录。不需要包含子目录
function f($dirPath,$toDirPath,$px='rar',$baseDirPath=''){
	//$dirPath=realpath($dirPath);
	empty($baseDirPath) && $baseDirPath=$dirPath;

	foreach((array)glob($dirPath."/*") as $val){
		//echo "<font color=green>",$val,"</font>","<br>\n";
			$tmp_=explode(".",$val);
			if(strtolower(array_pop($tmp_))==$px){
				$newDirPath=$toDirPath."/".str_replace($baseDirPath,"",$dirPath);
				///echo $newDirPath."/".basename($val),"<br>\n";
				@mkdir($newDirPath,0777,true);
				
				
				
				copy($val,$newDirPath."/".preg_replace('/^.+[\\\\\\/]/', '', $val));  //支持中文文件的复制
			}
		
	}
}


f(dirname(__FILE__)."/file",dirname(__FILE__)."/file3",'txt');


6.拷贝某目录下所有后缀rar文件（包含中文名，空格），到另外一个新目录。需要包含子目录
function f($dirPath,$toDirPath,$px='rar',$baseDirPath=''){
	//$dirPath=realpath($dirPath);
	empty($baseDirPath) && $baseDirPath=$dirPath;

	foreach((array)glob($dirPath."/*") as $val){
		//echo "<font color=green>",$val,"</font>","<br>\n";
		if(is_dir($val)){
			f($val,$toDirPath,$px,$baseDirPath);
		}else{
			$tmp_=explode(".",$val);
			if(strtolower(array_pop($tmp_))==$px){
				$newDirPath=$toDirPath."/".str_replace($baseDirPath,"",$dirPath);
				///echo $newDirPath."/".basename($val),"<br>\n";
				@mkdir($newDirPath,0777,true);
				
				
				
				copy($val,$newDirPath."/".preg_replace('/^.+[\\\\\\/]/', '', $val));  //支持中文文件的复制
			}
		}
	}
}


f(dirname(__FILE__)."/file",dirname(__FILE__)."/file2",'txt');


7.删除一个含有文件的目录，包括子目录
function d($dirPath){
	foreach((array)glob($dirPath."/*") as $val){
		if(is_dir($val)){
			d($val);
		}else{
			//echo "<font color=blue>",$val,"</font><br>\n";
			unlink($val);
		}
	}

	//echo "<font color=red>",$dirPath,"</font><br>\n";
	rmdir($dirPath);
}


8.glob递归查找所指定文件(子文件夹)下的所有文件
function z($dirpath){
  $r=array();
  foreach (glob($dirpath."/*") as $filename) {
    //echo "$filename size " . filesize($filename) . "\n";

    if(is_dir($filename)){
      
        $r=array_merge($r,z($filename));
    }else{


      $r[]=$filename;
    }
    
  }

  return $r;
}

echo "<pre>";
print_r(z(dirname(__FILE__)));	
9.编写一个资源管理器,要求:找出所以指定文件下的所有文件及文件的大小

//要用到$_GET,可提前说,或者以后作业

function z($dirpath){
  $r=array(0=>array(),1=>array());
  foreach (glob($dirpath."/*") as $filename) {
  if(is_file($filename)){
		$r[1][]=realpath($filename);

  }else if(is_dir($filename)){
		$r[0][]=realpath($filename);
  }
    
  }

  return $r;
}

$dirPath=dirname(__FILE__)."/file";
if(!empty($_GET['dirPath'])){
	$dirPath=$_GET['dirPath'];
}

//echo "<pre>";
//print_r(z($dirPath));
list($dir,$file)=z($dirPath);
foreach($dir as $val){
	echo "<a href='".$_SERVER['PHP_SELF']."?dirPath=".$val."'>".preg_replace('/^.+[\\\\\\/]/', '', $val)."</a><br>\n";
}


foreach($file as $val){
	echo preg_replace('/^.+[\\\\\\/]/', '', $val)." [".filesize($val)." 字节]<br>\n";
}

//在上述基础上,可以增加对文件的增\删\改


10.取文件后缀,用文件处理函数
pathinfo;
					 
</textarea></div>
												</li>
											  </ul>
											</li>					
		 </li>   
		</ul>		
</div></br>

	<div id="bio">
			<li class="title_white_r" id="st_4" ><h1><a href="###" style="cursor:point;text-decoration:none;">第四部分 时间函数</a></h1></li>
			<li id="tc_4" style="list-style:none;display:none"></br>
			<ul id="">
			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_50"> time date_default_timezone_set('prc');date_default_timezone_set('UTC')  <span>注:关于时区的设置可以在php.ini中对date.timezone=UTC设置</span></a></h1></li></br>	
						<li id="nr_50" style="display:none;">
                                            <ul id="">
											
			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_62">date_default_timezone_set('prc')<span>义:设定用于一个脚本中所有日期时间函数的时区,表示为中国时区,其他的date_default_timezone_set('Asia/Shanghai');//'Asia/Shanghai' 亚洲/上海
date_default_timezone_set('Asia/Chongqing');//其中Asia/Chongqing'为“亚洲/重庆”
date_default_timezone_set('Asia/Harbin');//其中'Asia/Harbin'为"亚洲/哈尔滨"等也可表示在中国时区
</span></a></h1></li></br>
<li id="de_62" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
 date_default_timezone_set("prc);
 echo date("Y-m-d H:i:s");
 //输出当前日期时间
						 


			                     </textarea></div>
												</li>
											  </ul>
											</li>

<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_63">date_default_timezone_set('UTC')  <span>义:设置默认时区,此时区与中国时区相差八个小时.
</span></a></h1></li></br>

<li id="de_63" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
								 
 date_default_timezone_set("utc);
 echo date("Y-m-d H:i:s");
 //输出当前日期时间
								 


			                     </textarea></div>
												</li>
											  </ul>
											</li>


</ul>
			</li>
			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_51">date  <span>注:格式化一个本地时间／日期</span></a></h1></li></br>	
			<li id="nr_51" style="list-style:none;display:none">
											  <ul>
											  		  	<li>
									 <img src="images/date_table.png" >
									</li>
											    <li>
												<div>
								 <textarea>
								 							 
 $time= date("Y-m-d H:i:s");
 echo "今天是".$time."&nbsp;".date("A")."&nbsp;".date("l")."&nbsp;,这是第".date("W")."周,今年的第".date("z")."天";
 
 
 //判断输入年份是闰年还是平年
 function mydate($year){
   if($year%4==0 && $year%100!=0 ||$year%400==0){
      echo $year."是闰年";
   }else{
      echo $year."是平年";
   }
 }
 mydate(2015);
 
 业务:可以利用时间函数编写日志,备忘录;以时间为前缀的目录;任务/工作进程等等

			                     </textarea></div>
												</li>
								
											  </ul>
											</li>
											
											
			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_52">strtotime(更多参数请翻阅php手册)  <span>注:int strtotime ( string $time [, int $now ] )任何英文文本的日期时间描述解析为 Unix 时间戳,用来计算返回值的时间戳。 </span></a></h1></li></br>	
			<li id="nr_52" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 							 
 echo strtotime('now')."<br>";     //获得当前时间的时间戳
 echo date("Y-m-d H:i:s",strtotime('now'))."<br>";    //将当前时间的时间戳格式化
 echo date("Y-m-d H:i:s",strtotime('+1 day'))."<br>";     //格式化时间+1天
 
 echo  date("Y-m-d H:i:s",strtotime("+1 week 2 days 4 hours 2 seconds",time()));    //在当前的时间上进行累加
 
$str = 'now';
if (($timestamp = strtotime($str)) === false) {
    echo "The string ($str) is error time";
} else {
    echo "$str == " . date('Y-m-d H:i:s A', $timestamp);
}


//银行信用卡账单日与还款日之间的业务处理,假定账单日与还款日时间间隔在25天
function pay($a,$b){
   $start=strtotime($a)/86400;
   $end=strtotime($b)/86400;
   //echo $start;
   //echo $end;
   //echo $c=$start-$end;
   if($start>$end){
     echo "抱歉,你输入的日期有误";
   }else if($end-$start==25){
     echo "您的信用卡即将需要还款";
   }else if($end-$start>25){
     echo "您已逾期,请及还款";
   }else{
     echo "还款日未到,请放心消费";
   }
   
   
}
pay("2015-06-01","2015-06-19");
			                     </textarea></div>
												</li>
								
											  </ul>
											</li>
						
		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_53">mktime  <span>义:取得一个日期的 Unix 时间戳,int mktime ([ int $hour [, int $minute [, int $second [, int $month [, int $day [, int $year [, int $is_dst ]]]]]]] )</span></a></h1></li></br>	
			<li id="nr_53" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 							 
//mktime() 在做日期计算和验证方面很有用，它会自动计算超出范围的输入的正确值,但缺陷在于必须按照规定的格式
echo date("M-d-Y", mktime(0, 0, 0, 12, 32, 2015));
echo date("M-d-Y", mktime(0, 0, 0, 13, 1, 2015));
echo date("M-d-Y", mktime(0, 0, 0, 13, 1, 15));*/
//输出的都是Jan-01-2016

//php获取今日开始时间戳和结束时间戳
$beginToday=mktime(0,0,0,date('m'),date('d'),date('Y'));	
$endToday=mktime(0,0,0,date('m'),date('d')+1,date('Y'))-1;
//时间戳格式化
echo date("Y-m-d H:i:s",$beginToday)."<br>";
echo  date("Y-m-d H:i:s",$endToday);
输出:
2015-06-19 00:00:00
2015-06-19 23:59:59
			                     </textarea></div>
												</li>
								
											  </ul>
											</li>					
											
				<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_58">作业  <span></span></a></h1></li></br>	
			<li id="nr_58" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

1.写一个计算时间差的函数
2.遍历时间段:for
3.生日程序
单位人员的生日都保存在一个文本中，现在需要有一个程序，能自动输出一段文字，祝贺当天过生日的职工
4.大学入学星期几(编写函数)                     
								 </textarea></div>
												</li>
								
											  </ul>
											</li>	
												<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_57">部分答案  <span></span></a></h1></li></br>	
			<li id="nr_57" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>

1.写一个计算时间差的函数
function caculate($start,$end){
   $start=strtotime($start);
   $end=strtotime($end);
   $result=($end-$start)/86400;
   echo date('Y-m-d',$end)."与".date('Y-m-d',$start).'差'.$result.'天';
}
caculate("2015-06-22","2015-06-25");


2.遍历时间段:for
一.
function y($s1,$s2){
	$r=array();
	$s1=strtotime($s1);
	$s2=strtotime($s2);
	


	foreach (range($s1, $s2,86400) as $number) {
	   $r[]=date("Y-m-d",$number);
	}
    echo "<pre>";
	print_r($r);

}
y("2015-06-22","2015-07-25");


二.

function x($n){
return date('Y-m-d', $n);
}


function date_rang($start_date, $end_date){

		return $ccc=array_map('x', range(   strtotime($start_date), strtotime($end_date), 24*3600  ));
}

print_r(date_rang('2015-06-24','2015-07-24'));


3.生日程序
单位人员的生日都保存在一个文本中，现在需要有一个程序，能自动输出一段文字，祝贺当天过生日的职工

function birthday($file){
$arr=file($file,FILE_IGNORE_NEW_LINES|FILE_SKIP_EMPTY_LINES );
//echo $content;

echo "<pre>";
print_r($arr);

$names=array();
for($i=0;$i<count($arr);$i++){
 $birth=explode("|",$arr[$i]);
 
 if(substr($birth[1],-5)==date("m-d")){
	
	$names[]=$birth[0];
	echo $birth[0]."生日快乐";
	
  }
  
  
}
 return $names;

 }
 
 $file=dirname(__FILE__)."/file/birthday.txt";
 
 echo "<pre>";
 birthday($file);
 
4.大学入学星期几
function getWeek($unixTime){
 $weekarray=array('日','一','二','三','四','五','六');
 return '星期'.$weekarray[date('w',strtotime($unixTime))];
}
echo getWeek("2015-09-01");




			                     </textarea></div>
												</li>
								
											  </ul>
											</li>							
			</ul>
			</li>
			</div><br>
				<div id="bio">
			<li class="title_white_r" id="st_5" ><h1><a href="###" style="cursor:point;text-decoration:none;">第五部分 序列化函数（AJAX）</a></h1></li>
			<li id="tc_5" style="list-style:none;display:none"></br>
			<ul id="">
	<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_59">serialize/unserialize&&&&json_encode/json_decode<span></span></a></h1></li></br>	
						<li id="nr_59" style="display:none;">
                                            <ul id="">
											
			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_70">serialize  <span>义:产生一个可存储的值的表示 .

</span></a></h1></li></br>
<li id="de_70" style="list-style:none;display:none">
											  <ul>
											    <li>
												<div>
								 <textarea>
								 
$array=array('a'=>'aaa','b'=>'bbb',array('c'=>'我是谁','你是谁'));
$fp=fopen(dirname(__FILE__)."/file/diary.txt","a+");
$content=fwrite($fp,serialize($array)."\r\n");
echo file_get_contents(dirname(__FILE__)."/file/diary.txt");        //输出的是序列化后的内容
fclose($fp);

			                     </textarea></div>
												</li>
											  </ul>
											</li>

<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_66">unserialize  <span>义:从已存储的表示中创建 PHP 的值 
</span></a></h1></li></br>

<li id="de_66" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
	 
$content=file_get_contents(dirname(__FILE__)."/file/diary.txt");
print_r( unserialize($content));

			                     </textarea></div>
												</li>
											  </ul>
											</li>
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_67">json_encode<span> 义:对变量进行 JSON 编码.string json_encode ( mixed $value )返回 value 值的 JSON 形式 或者在失败时返回 FALSE
</span> 
</a></h1></li></br>

<li id="de_67" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
	 
$arr = array ('a'=>1,'b'=>2,'c'=>3,'d'=>4,'e'=>5);
echo serialize($arr)."<br>";
echo json_encode($arr);      //感受下两者的区别



			                     </textarea></div>
												</li>
											  </ul>
											</li>
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_68">json_decode<span> 
</span></a></h1></li></br>

<li id="de_68" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
$arr = array ('a'=>1,'b'=>2,'c'=>3,'d'=>4,'e'=>5);
echo "<pre>";
print_r(json_decode(json_encode($arr)));
print_r (json_decode(json_encode($arr)));
两者分别打印输出:
stdClass Object
(
    [a] => 1
    [b] => 2
    [c] => 3
    [d] => 4
    [e] => 5
)
stdClass Object
(
    [a] => 1
    [b] => 2
    [c] => 3
    [d] => 4
    [e] => 5
)

			                     </textarea></div>
												</li>
											  </ul>
											</li>
																				<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_69">总结<span> 
</span></a></h1></li></br>

<li id="de_69" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>

注:
serialize/unserialize是PHP自身的使用的	 

业务:对数据库结果集序列化后存入到文本中,用户请求时进行判断,有没有序列化后的文本,若有,就从文本取出数据,降低数据库的压力.

json_encode/json_decode  其他语言都有类似的函数,生成的字符串可以给多种语言使用,作为多语言之间数据传递用.
把一个对象或数组转换成字符串,作用:方便在网络中传输;方便存储.

业务作用:json手机app  java/ios向服务器请求的命令转换成json格式提交到服务器,服务器端的语言无论是否是php,都有具备的反函数将其转换为数组或对象,再进行处理.同样的服务端处理完后也需要将数据转换成json格式返回给手机端.

备注:xml格式也是多语言之间数据传递常用格式.


			                     </textarea></div>
												</li>
											  </ul>
											</li>
            </ul>
			</li>

			<li>
				<h1>
					<a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_62">AJAX<span></span>
					</a>
				</h1>
			</li>
			
			</br>

			<li id="nr_62" style="display:none;">
				<ul id="">
<pre>
<b>1.什么是ajax？</b>
想让用户当前浏览的页面，其中内容发生改变，但又不想刷新页面
例如：
	用户注册时，当他写好一个用户名：admin，想在网页上提示他这个用户名已经存在了，不能注册
	那么通常，只有他提交form表单后，服务端程序PHP到数据库中去查询是否有该用户，若有，输出相应信息
	这样，用户体验就较差，用户好不容易想出来一个自己喜欢的名字，但他只有在提交后，才能知道用户名能不能用，然后再重新想一个用户名，再提交……这样反复，用户试了2-3个，都通不过，可能就不想注册了
	若能在其提交注册表单之前，就告诉他，用户名是否能用，用户体验就好多了

因此，通常，我们想要更新网页某些内容，如提示用户名是否存在(可以提示文字或者小勾/小叉的图片)，那么只有刷新当前页面，或者转跳页面：包括了使用超链接和form提交，才能完成

除此之外，我们就可以使用AJAX：无刷新更新页面

<b>2.如何使用ajax</b>
ajax是基于xml的http请求，可模拟浏览器和服务端的对话，使用javascript调用
当前，我们真正使用时，是使用jquery封装好的方式，因为涉及到请求的返回值，故在当前php基础里说
如下：
！！！这个是html 页面，必须以http形式访问

最简单的第1个例子

test.html
<textarea>
<!-- 
！！！当前页面必须以http形式访问！！！
-->
<html>
<head>
<meta charset="utf-8">
<script src="./js/jquery-1.7.1.js"></script>

<script>
function page_checkUser(username2){

//{"a":1,"b":2,"c":"字符串"}
$.ajax(
		{
			url: "./test_ajax.php",	//提交到哪个程序.能http访问的
			type: "post",			//1.和程序页：$_POST 配对
			data: {'username':username2}, //2.和程序页：变量键名配$_POST['username']
			
			async: true,
			dataType: "json",		//3.和程序页：json_encode配对
			success: function(data){//4.和程序页：json_encode的参数值配对
			
				alert(data['code']);
				alert(data['info']);
			}
		}
		
		);
}

</script>
</head>


<body>

<form method="post" action="">

用户名：<input id="username" name="username" onblur="page_checkUser(this.value)"><br>

<input type="submit">
</form>


</body>
</html>

</textarea>


test_ajax.php
<textarea>
<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国

//print_r($_GET);
//print_r($_POST);


if($_POST['username']=='admin'){
	$data=array(
		"code"=>-1,
		"info"=>"不能注册"
	);

	echo json_encode($data);
	
}else{
	$data=array(
		"code"=>1,
		"info"=>"可以注册"
	);
	echo json_encode($data);
}



?>
</textarea>


第2个例子
<textarea>
<!-- 
！！！当前页面必须以http形式访问！！！
-->
<html>
<head>
	<meta charset="utf-8">
	<script src="./js/jquery-1.7.1.js"></script>

	<script>
		$(document).ready(
			function (){
				$("#username").bind(
					"blur",//焦点失去时
					function (){
						//调用一个函数，检查用户名
						page_checkUser($(this).val());
						
						//可以直接在这里写ajax请求，而不放在函数里面
					}
				)
			}
		)

		//定义：表单提交前 每个提交域 检查的结果
		var page_check={
						'username':0,
						'password':0
						}

		//在自定义函数里，用ajax检查用户名是否存在
		function page_checkUser(username){
			
			//$.ajax是jquery的一个函数。
			//用它可以进行ajax请求。
			//它的参数是一个对象。
			//除了以下写法，还有很多其他写法
			$.ajax(
					{
						url: "http://127.0.0.1/example/ajax/ajax_check_username.php",//提交到哪个url。要能http访问的

						type: "POST",//提交模式：post/get

						data: {//提交哪些变量。
								//若post模式，则 上述的url，使用$_POST['uname']接收
								//若get模式，则 上述的url，使用$_GET['uname']接收
								'username':username,//

								'other':'其他一些数据',//当前不需要加
								'tmp':Math.random() //产生随机数，防止有缓存影响。当前可不加
							},

						async: true,//true/false:异步(默认)/同步：
									//异步，则等待服务端返回值时，当前页面不僵住
									//同步，则等待服务端返回值时，当前僵住

						dataType: "json",//服务端数据返回格式。包括：json/html/script/text/xml

						success: function(data){//服务端 返回值的处理
							//data 是服务端返回的数据
							//这个data 可以是字符串/数组/对象等
							//data类型是由 服务端 当时发送数据时，定义好的
							//但 data类型，必须和 dataType 一致，否则返回值无效

							//当前是返回值是一个对象，有2个属性：
							//code：代表状态码，当前请求的结果，用户名能否注册
							//info：代表，无论请求的结果，中文说明是什么。为了给用户看

						//！！！1.判断 请求结果，在业务上是否成功 
							//通常这是必须的，
							//除非你的这次ajax请求，不管业务是否成功
							if(data.code<0){//若不能注册。可以写 data['code']
								page_check.username=0;//对 提交域 检查的结果 变量赋值
							}else{//若能注册
								page_check.username=1;//对 提交域 检查的结果 变量赋值
							}

						//！！！2.调用另外一个函数处理页面效果
							//通常这是必须的。可以直接在当前写，不用函数
							//但必须有，除非你的这次ajax请求的结果，不需要给用户看
							page_showInfo($("#username"),data);






							//若返回的是字符串或数字，则可以这样测试下看看
							//alert(data);

							//若返回的是数组，则可以这样测试下看看看
							//for(var i=0;i<data.length;i++){alert(data[i])} 


							//若返回的是对象，则可以这样测试下看看看
							//for(var key in data ){alert(data[key])} 

						}


						////////////其他的一些参数，可不用
						//cache: false,//true/false:缓存(默认)/不缓存。可不填
						//timeout:10000,//服务端多少 毫秒 不响应，算超时。可不填
						//error:page_ajaxRetrunErr ,//出错时，使用什么函数处理。可不填
					}
				);
		}


		//处理页面效果
		function page_showInfo(e,data){
			var eShow=e.next("span");//这个span的作用，就是预留下来准备放置用户看的信息的容器

			eShow.html(data.info);

			//以下作为作业
			//if(data.code>0){//如果 返回值 编码大于0
			//	//那么可以显示绿色的小勾子图片
			//}else{//否则
			//	//那么可以显示红色的小叉子图片
			//}
		}


		//表单提交前 每个提交域 检查的结果
		function page_submit(){
			for(var key in page_check){
				if(page_check[key]==0){
					alert("通不过验证！");
					return false; //返回布尔值，给onsubmit
				}
			}

			return true; //返回布尔值，给onsubmit
		}

	</script>
</head>


<body>
<!-- 
	onsubmit 拦截提交，前置验证
	必须 return 布尔值
-->
<form method="post" action="" onsubmit="return page_submit()">
用户名：<input id="username" name="username"><span></span><br>
密码：<input type="password" id="password" name="password"><span></span><br>
<input type="submit">
<!-- <input type="submit" onclick="return page_submit()"> 用这种方式也可以-->
</form>
</body>
</html>
</textarea>


服务端php响应程序：ajax_check_username.php
<textarea>
<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误


//1.先看一下提交过来的是什么样的情况
	//请用火狐，f12，查看结果
	//print_r($_POST);
	//print_r($_GET);

//2.然后，做一些数据库查询，看是否有该用户名

//3.之后 组装返回值
//是否一定要组装成这种形式，根据实际需要
//通常 给出 code/info 2个类似的值，返回时，请求页面比较好判断业务结果，然后做处理
$data=array(
			'code'=> -1,
			'info'=> "该用户名已经存在",
		);

//4.最后 使用json输出
echo json_encode($data);

//这个实际的结果是：
//{"code":-1,"info":"该用户名已经存在"}



//////////////可以输出其他类型的
//echo "alert(123)"; //要求：ajax请求的dataType="script"。返回值当js脚本执行
//echo "<p>123</p>"; //要求：ajax请求的dataType="html"。返回值当html形式的文本
?>
</textarea>

<font color=red>$('#replayForm').serialize(),</font>

</pre>

<li class="homework">
		作业：<br>
		扩展教案例子：(代码拷贝给学生)<br>
		1.将用户名是否存在验证，用真实数据库查询完成<br>
		2.用户名无论验证成功或失败，显示勾子或者叉子的图片<br>
		3.验证用户邮箱是否唯一，用真实数据库查询完成<br>
		4.验证密码是否是英文和数字组成(不需要ajax)<br>
		5.验证密码，和重复密码是否一致(不需要ajax)<br>
		
		<span class="answer">答案</span>：略<br>
	</li>

				</ul>
			</li>

		




			</ul>
			</li>
	</div><br>
	<div id="bio">
	<li class="title_white_r" id="st_6" ><h1><a href="###" style="cursor:point;text-decoration:none;">第六部分 URL处理函数</a></h1></li>
			<li id="tc_6" style="list-style:none;display:none"></br>
			<ul id="">
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_60">http_build_query/parse_str<span></span></a></h1></li></br>				
			<li id="nr_60" style="display:none;">
                                            <ul id="">
	<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_71">http_build_query<span> 义:生成 URL-encode 之后的请求字符串.string http_build_query ( array $formdata [, string $numeric_prefix ] )
</span></a></h1></li></br>

<li id="de_71" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
								 
$array=array("a"=>"aaa","b"=>"bbb",array("c"=>"ccc"));
echo http_build_query($array)."<br>";
输出:
a=aaa&b=bbb&0%5Bc%5D=ccc


//带有数字下标的
$arr=array("aaa","bbb","ccc",array("ddd eee"));
echo http_build_query($arr)."<br>";
//输出:0=aaa&1=bbb&2=ccc&3%5B0%5D=ddd+eee
echo http_build_query($arr,'prefix_');     //注:如果在基础数组中使用了数字下标同时给出了 numeric_prefix 参数，此参数值将会作为基础数组中的数字下标元素的前缀。这是为了让PHP或其它程序在稍后对数据进行解码时获取合法的变量名
//输出:prefix_0=aaa&prefix_1=bbb&prefix_2=ccc&prefix_3%5B0%5D=ddd+eee

			                     </textarea></div>
												</li>
											  </ul>
											</li>										
										<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_72">parse_str<span> 义:函数把查询字符串解析到变量中。parse_str(string,array)
</span></a></h1></li></br>

<li id="de_72" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
$str = "first=我是谁&arr[]=foo+你是谁&arr[]=baz";
parse_str($str);
echo $first."<br>";  // value
echo $arr[0]."<br>"; // foo bar
echo $arr[1]."<br>"; // baz
输出:
我是谁
foo 你是谁
baz


parse_str($str,$arr2);
echo $arr2['first']."<br>";
echo $arr2['arr'][0]."<br>";
echo $arr2['arr'][1]."<br>";
输出:
我是谁
foo 你是谁
baz								 

			                     </textarea></div>
												</li>
											  </ul>
											</li>				
										
											</ul>
											</li>
																		<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_73">parse_url<span> 义:解析 URL，返回其组成部分.本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。 
</span></a></h1></li></br>

<li id="de_73" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
注:本函数不能用于相对 URL。 						 
$url="http://www.baidu.com?keyword='中国'&search='文明'";
echo "<pre>";
print_r( parse_url($url));
打印出:					 
Array
(
    [scheme] => http
    [host] => www.baidu.com
    [query] => keyword='中国'&search='文明'
)
			                     </textarea></div>
												</li>
											  </ul>
											</li>
						<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_61">urlencode/urldecode <span></span></a></h1></li></br>				
			<li id="nr_61" style="display:none;">
                                            <ul id="">					
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_74">urlencode<span> 义:编码 URL 字符串
</span></a></h1></li></br>

<li id="de_74" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
								 
echo urlencode("中文-_. ")."<br>";
//输出:%D6%D0%CE%C4-_.+
echo urlencode("我是谁")."<br>";
//输出:%CE%D2%CA%C7%CB%AD

$EncodeStr=urlencode("www.baidu.com?a=aa&b=cc");
echo "<a href=finatest.php?n=$EncodeStr>个人信息</a>";
//当点击个人信息后,在浏览器的地址栏会显示转码内容


注:注册完成回到上一页来源时,把上一页的url地址以get方式传给注册页面,传递时用以上函数进行处理,防止发生错误.
			                     </textarea></div>
												</li>
											  </ul>
											</li>
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_75">urldecode<span> 义: 解码已编码的 URL 字符串
</span></a></h1></li></br>

<li id="de_75" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>

$string="欢迎来到诺博源学习PHP";
echo  urlencode($string)."<br>";
//输出:%BB%B6%D3%AD%C0%B4%B5%BD%C5%B5%B2%A9%D4%B4%D1%A7%CF%B0PHP
echo urldecode(urlencode($string));	
//输出:欢迎来到诺博源学习PHP									
								
                                 </textarea></div>
												</li>
											  </ul>
											</li>											
			
											</ul>	
											</li>		
			
			</ul>
			</li>
	</div><br>
	<div id="bio">
	<li class="title_white_r" id="st_7" ><h1><a href="###" style="cursor:point;text-decoration:none;">第七部分 GET/POST</a></h1></li>
			<li id="tc_7" style="list-style:none;display:none"></br>
			<ul id="">
			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="ertitle" id="bt_60"> GET/POST<span>义:页面传值所用.我们分四个方面来体会和理解两者之间的区别</span></a></h1></li></br>	
			<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_76">一:<span>从提交长度来看</span></a></h1></li></br>

<li id="de_76" style="list-style:none;display:none">
											  <ul>

											    <li>
												<div>
								 <textarea>

get是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。很多文章都说GET方式提交的数据最多只能是1024字节，而实际上，URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统。即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。

post理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去，以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.conf的post_max_size这个值。									

                                 </textarea></div>
												</li>
											  </ul>
											</li>
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_77">二:<span>从安全性来看</span></a></h1></li></br>

<li id="de_77" style="list-style:none;display:none">
											  <ul>

											    <li>
												<div>
								 <textarea>

get安全性非常低，post安全性较高。但是执行效率却比Post方法好
1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；
2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；									
                                 </textarea></div>
												</li>
											  </ul>
											</li>		
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_78">三:<span>从form的属性。</span></a></h1></li></br>

<li id="de_78" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>

Get将表单中数据的按照variable=value的形式，添加到action所指向的URL后面，并且两者使用“?”连接，而各个变量之间使用“&”连接；
Post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL。

创建文件form.php,以get的方式进行数据的提交,提交页面指向get_post.php
<form action="get_post.php" method="get"> 
   姓名:<input type="text" name="name"><br><br>
   号码:<input type="text" name="tel"><br><br>
   性别:<input type="radio" name="sex" value="男生">男生
       <input type="radio" name="sex" value="女生">女生<br><br>
   <input type="submit" value="提交">
   <input type="reset" value="清空">
</form>

创建文件get_post.php,输出本框和单选框的值
<?php
  echo "姓名:".$_GET["name"]."<br>";
  echo "号码".$_GET["tel"]."<br>";
  echo "性别".$_GET["sex"]."<br>";
  

?>

创建文件form.php,以post的方式进行数据的提交,提交页面指向get_post.php
<form action="get_post.php" method="post"> 
   姓名:<input type="text" name="name"><br><br>
   号码:<input type="text" name="tel"><br><br>
   性别:<input type="radio" name="sex" value="男生">男生
       <input type="radio" name="sex" value="女生">女生<br><br>
   <input type="submit" value="提交">
   <input type="reset" value="清空">
</form>


创建文件get_post.php,输出本框和单选框的值
<?php
  echo "姓名:".$_POST["name"]."<br>";
  echo "号码".$_POST["tel"]."<br>";
  echo "性别".$_POST["sex"]."<br>";
  

?>

注:
1.判断是get/post提交,是看form表单中method是以get/post形式显示.
2.显示所提交的值,关键是找出表单标签的name值, 即echo $_GET["表单name的值"]或echo $_POST["表单name的值"].                                </textarea></div>
												</li>
											  </ul>
											</li>		
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_79">四:<span>此外post时，不响应action上的get参数</span></a></h1></li></br>

<li id="de_79" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
注:当表单提交方式是以post提交,而同时在url中进行数据提交时,数据的提交是以post方式,不响应get参数进行的数据提交
//建立get_post.php文件
//在文本框输入内容后点击提交
<form action="get_post.php?a=123&b=456" method="post">
   姓名:<input type="text" name="name"><br><br>
   号码:<input type="text" name="tel"><br><br>
   <input type="submit" value="提交">
   <input type="reset" value="清空">
</form>
<?php
echo "<pre>";
print_r($_GET);
print_r($_POST);
?>
打印出:
Array
(
    [a] => 123
    [b] => 456
)
Array
(
    [name] => EEE
    [tel] => eeee
)
//地址栏上显示 get_post.php?a=123&b=456


//在文本框输入内容后点击提交
<form action="get_post.php?a=123&b=456" method="get">
   姓名:<input type="text" name="name"><br><br>
   号码:<input type="text" name="tel"><br><br>
   <input type="submit" value="提交">
   <input type="reset" value="清空">
</form>
<?php
echo "<pre>";
print_r($_GET);
?>
在文本框中输入张三,110
打印出:
Array
(
    [name] => 张三
    [tel] => 110
)
//地址栏上显示是根据表单文本框中所提交的数据的相对应的值
 

                                 </textarea></div>
												</li>
											  </ul>
											</li>			
			</ul> 
			</li>
	</div><br>
	<div id="bio">
	<li class="title_white_r" id="st_8" ><h1><a href="###" style="cursor:point;text-decoration:none;">第八部分 $_FILE 文件上传</a></h1></li>
			<li id="tc_8" style="list-style:none;display:none"></br>
			<ul id="">
			  					<div>
								 <textarea>

//建立uplode.php文件,创建表单代码,代码如下
<html>

<body>

<!-- form 必须是 post提交 -->
<!-- form 必须加   enctype="multipart/form-data" -->
<!-- form 中 type="file" 的文本框 是上传的容器。它的name 会被接收页面使用-->
<form  method="post" enctype="multipart/form-data" action="file_uplode.php">
	<input type="file"  name="upFile">
	
	<br><br>
	<input type="submit" value="提交">
</form>
</body>
</html>


//建立file_uplode.php,编写上传文件代码,代码如下
<?php

//$_FILES 是接收上传文件的 超全局变量。只有它有值，才说明有上传
if(!empty($_FILES)){

	//$_FILES是个2维的数组，以 form 中 file 文本框 的 name 作为 数组元素的键名
	//键值是1维数组，其中键名有：
	//name：用户上传的原文件名称
	//type：该文件类型
	//tmp_name：上传后，已经保存在服务器的临时文件夹里的什么位置。
				//1.上传流程是：用户提交/服务器接收，并保存成临时文件/程序员，将保存的临时文件，移动到想要的地方
				//2.当程序员处理时，其实文件已经上传完毕了。

	//error：上传过程中有没有错。
				// 0：没有错。
				// 1/2/3/4/5/6/7：上传的文件超过了 php.ini 设置的大小/上传超过MAX_FILE_SIZE 大小/只有部分被上传/没有文件被上传/找不到临时文件夹/文件写入失败
				// 打开php.ini，找到 upload_max_filesize ，可设置上传大小。post_max_size ，设置 post上传大小。重新服务

	//size：上传文件的大小。字节

	echo "<pre>";
	print_r($_FILES);
	//exit;


	//作为一个程序员开始处理

	//如果没有错误
	if($_FILES['upFile']['error']==0){

		//通过文件后缀，判断是否允许上传的文件
		$suffix=substr(strrchr($_FILES['upFile']['name'],'.'),1); //还能用什么方式？
		if(!in_array($suffix,array('jpg','png','gif','zip','rar','xls','doc'))){
			exit("该文件类型不允许上传！");
		}

		//建立一个文件夹，为了把上传文件真正放到该位置。
		$fileDir=dirname(__FILE__)."/upload/".date("Y-m-d");//组织好想要的文件夹名称。当前以日期命名。可以以登录用户的手机号，每个用户文件传到自己文件夹。或者其他命名规则
		@mkdir($fileDir,0777,true);//递归建立文件夹
		//判断文件夹是否创建成功
		if(!is_dir($fileDir)){
			exit("建立文件夹失败！");
		}

		//重新组织文件名称。通常不会使用用户上传的文件名。
		//为了安全和兼容，会使用英文和数字。并要唯一
		//用户原文件名，如需要，会保存到数据库
		$fileName=md5(uniqid('', true).$_FILES['upFile']['name']);
		$fileName.='.'.$suffix;//并接上后缀

		//拼装成全路径
		$filePath=$fileDir.'/'.$fileName;
		//echo $filePath;exit;

		//最后操作：将临时文件，移动到自己想要地方
		if(move_uploaded_file($_FILES['upFile']['tmp_name'],$filePath)==true){
			echo "上传成功";
		}else{
			echo "上传失败";
		}


		
	}else{
		echo "上传错误：".$_FILES['upFile']['error'];
	}
}
?>
                                 </textarea></div>
			</ul>
			</li>
	</div><br>
	<div id="bio">
	<li class="title_white_r" id="st_9" ><h1><a href="###" style="cursor:point;text-decoration:none;">第九部分 $_SERVER中键名</a></h1></li>
			<li id="tc_9" style="list-style:none;display:none"></br>
			<ul id="">
<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_80">HTTP_REFERER <span>义:引导用户代理到当前页的前一页的地址（如果存在）。 </span></a></h1></li></br>

<li id="de_80" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
//创建show_server.php文件,代码如下:
<?php
echo '<a href="abc.php">点一下</a>';
?>

//创建abc.php文件,代码如下:

<?php
 echo $_SERVER["HTTP_REFERER"];
?>

//当在show_server.php页面的链接后,会在abc.php页面显示上一页面的地址.
                                 </textarea></div>
												</li>
											  </ul>
											</li>	
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_81">HTTP_HOST<span>义:当前请求头中 Host: 项的内容，如果存在的话。  </span></a></h1></li></br>

<li id="de_81" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>

//创建show_server.php文件,代码如下:
<?php
echo '<a href="abc.php">点一下</a>';
?>

//创建abc.php文件,代码如下:

<?php
 echo $_SERVER["HTTP_HOST"];
?>

//当在show_server.php页面的链接后,会在abc.php页面显示当前获取的服务器域名.如localhost.
                                 </textarea></div>
												</li>
											  </ul>
											</li>	
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_82">REMOTE_ADDR <span>义:当前用户的 IP 地址。 </span></a></h1></li></br>

<li id="de_82" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
//在后缀为php的文件代码中输入:
<?php
echo $_SERVER["REMOTE_ADDR"];
//输出浏览当前页面的用户的 IP 地址。如127.0.1
?>

                                 </textarea></div>
												</li>
											  </ul>
											</li>	
											<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_83">DOCUMENT_ROOT <span>义:当前运行脚本所在的文档根目录。在服务器配置文件中定义。 </span></a></h1></li></br>

<li id="de_83" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>

//在后缀为php的文件代码中输入:
<?php
echo $_SERVER["DOCUMENT_ROOT"];
//显示当前页面运行的根目录
?>
                                 </textarea></div>
												</li>
											  </ul>
											</li>	<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_84">QUERY_STRING <span>义:query string（查询字符串），如果有的话，通过它进行页面访问。  </span></a></h1></li></br>

<li id="de_84" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>

//创建show_server.php文件,代码如下:
<?php
echo '<a href="abc.php?a=123&b=456">点一下</a>';
?>

//创建abc.php文件,代码如下:

<?php
 echo $_SERVER["QUERY_STRING"];
?>
//页面输出:a=123&b=456
                                 </textarea></div>
												</li>
											  </ul>
											</li>	<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_85">REQUEST_URI <span>义:URI 用来指定要访问的页面。例如 “/index.html”。 </span></a></h1></li></br>

<li id="de_85" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>
/创建show_server.php文件,代码如下:
<?php
echo $_SERVER["REQUEST_URI"];
//取得当前URL的路径地址
?>


                                 </textarea></div>
												</li>
											  </ul>
											</li>	<li><h1><a href="###" style="cursor:point;text-decoration:none;" class="details" id="sh_86">PHP_SELF <span>义:当前执行脚本的文件名，与 document root 有关。从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 </span></a></h1></li></br>

<li id="de_86" style="list-style:none;display:none">
											  <ul>
									
											    <li>
												<div>
								 <textarea>

//创建show_server.php文件,代码如下:
<?php
echo $_SERVER["PHP_SELF"];
//取得当前URL的路径地址
?>

                                 </textarea></div>
												</li>
											  </ul>
											</li>		
			</ul>
			</li>
	</div>
	
	<br>


<div id="bio">
	<li>
		<h1>
			<a href="###" style="cursor:point;text-decoration:none;" class="hs_1">第十部分 session/cookie</a>
		</h1>
	</li>

	<ul>
	<li>
		<b>1.定义：会话控制</b>。<br>
		也就是，有一个用户在浏览器中，打开网站的一个页面，那么浏览器就会向服务器请求数据<br>
		当服务器返回的数据在浏览器中显示完成后，该用户电脑就和服务器中断了连接(web方式，无状态)<br>
		之后，当这个用户次再刷新页面，让浏览器重新向服务器请求时，此时：服务器是否能知道，这次的请求用户，是上一次的那个用户？
		<br><br>

		<b class="b2">若不能</b>：<br>
			客户输入用户名和密码，并登陆成功。之后刷新页面，服务器还会要你再次登陆，因为服务器不能记住你是谁，是否登陆过。不合理<br>
			客户做一个将商品加入购物车的操作时，服务器不知道这个商品应该加入谁的购物车，因为服务器不知道你是谁。不合理<br>
		<b class="b2">若能</b>：<br>
			则使用会话控制实现：session/cookie
	</li>
	</br>

	<li>
		<b>2.实现机制</b>。<br>
		当客户通过浏览器访问网站，服务器得到请求时，首先产生一个标志号：session_id，这个号在一段时间内，对于每个客户是唯一不同名的。<br>
		然后，服务器把这个标志号保存在硬盘上。通常是以这个标志号作为文件名，产生一个文件。这个文件又叫session文件<br>
		该文件位置，一般在操作系统的临时文件夹，window/temp 或者linux/tmp，或者根据php.ini配置文件自定义位置 <br><br>

		之后，当服务器返回数据时，会把这个标志号传给浏览器，同时给浏览器一个命令，请浏览器在客户电脑硬盘上也记住一个标志号：session_id。<br>
		通常是产生一个文件。把标志号保存在文件里面(键名默认为：PHPSESSID)。这个文件又叫cookie文件<br>
		该文件在客户电脑硬盘上的位置，一般在：window的浏览器临时文件夹下：Documents and settings/adminstrator/local settings/temporary internet files/<br><br>

		之后，客户通过浏览器再次刷新页面时，浏览器除了把请求提交给服务器，还会自动把刚才在硬盘上保存的session_id，发送给服务器<br>
		服务器拿这个session_id，寻找硬盘上有没有以此作为文件名的文件，如果有，就认为是上次的用户<br><br>

		这就好像超市存包：<br>
		服务器这个超市，为每个使用者都生成了一个不一样的存柜号，并把存根记录在服务器上，再把存柜票发给你<br>
		下次你来，如果带了自己的存柜号，通过检查服务器上存根，的确是真的，那么允许进入你的存柜，再次存取东西<br>
		下次你来，如果带了别人的存柜号，通过检查服务器上存根，的确是真的，那么允许进入别人的那个存柜，能存取别人的东西<br>
		下次你来，如果什么都没带，或者检查出存柜号是假的，那么服务器告诉你，只能为你重新生成一张新的存柜号，才能继续存取东西，而且以前的东西都再也找不到了<br>

	</li>
	</br>

	<li>
		<b>3.以上述机制为基础，看一下session/cookie 的异同点</b>。<br>
		<b class="b2">1)从作用上看</b>：都是为了保存用户会话，为了让服务器识别每个用户是上次来访的人<br>
		<b class="hs_2">2)从工作前提上看</b>：它们是共同工作的，它们必须通过同一个标志符号：session_id的传递，来共同工作。如果禁用了cookie，session_id会自动以$_GET传递<br>
		<span class="hs_2_son"><br>
			<textarea>
<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误
//ini_set("memory_limit", 2048576000);//设置内存最大字节数
//ini_set("max_execution_time", 24000);//设置执行时间为24000
//ini_set('default_socket_timeout',24000);//就是设置default_socket_timeout这个配置参

session_start();
echo "<pre>";

//session中的session_id
echo session_id();
echo "<br>";

print_r($_SESSION);

//cookie中存在的session_id
print_r($_COOKIE);//刷新2次以上能看到 PHPSESSID 键名
			</textarea>

			<br></span>
		<b class="b2">3)从保存内容上看</b>：它们都保存了session_id。同时它们也可以保存其他内容，如：登陆后的用户名，或者加入购物车的商品<br>
		<b class="hs_2">4)从程序中设置和获取的方式看</b>：它们都是超全局变量，可以跨页面获得和设置。它们赋值之前都不能有输出<br>
		<span class="hs_2_son">
		(1)session赋值和取值、删除，如下：<br>
<textarea>
<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误
//ini_set("memory_limit", 2048576000);//设置内存最大字节数
//ini_set("max_execution_time", 24000);//设置执行时间为24000
//ini_set('default_socket_timeout',24000);//就是设置default_socket_timeout这个配置参

//开启session
//在这之前不能有任何输出！！包括空格和html
session_start();

//输出session_id
echo session_id();

//给session赋值。可以赋数组值。本身好像一个数组一样
$_SESSION['a']=1;
$_SESSION['b']=array('b1'=>2,'b2'=>array(3,45));

//输出$_SESSION数组查看
//取值之前可以有输出
echo "<pre>";

//删除session某个键名
unset($_SESSION['b']['b1']);
print_r($_SESSION);
echo "<br>";
echo $_SESSION['b']['b2'][1];


//////////////////////////////////////////////////
//
// 之后，请把session赋值行，注释掉，可以发现还能输出，说明是超全局变量。
// 重写一个页面，仅获得session，也可以，说明在同一网站下，可以跨页面 
// 请在session_start()前进行输出，看看会发生什么 
//
/////////////////////////////////////////////////
</textarea>
<br>
之后，请把session赋值行，注释掉，可以发现还能输出，说明是超全局变量。<br>
并且可以重写一个页面，仅获得session，也可以，说明在同一网站下，可以跨页面<br>
请在session_start()前进行输出，看看会发生什么 <br>
<br>

		(2)cookie赋值和取值、删除，如下：<br>
<textarea>
<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误
//ini_set("memory_limit", 2048576000);//设置内存最大字节数
//ini_set("max_execution_time", 24000);//设置执行时间为24000
//ini_set('default_socket_timeout',24000);//就是设置default_socket_timeout这个配置参

//给cookie赋值。赋的值，不能是数组，只能是字符串或者数字。本身则像一个一维数组
//赋值之前不能有任何输出！！包括空格和html。
setcookie ( "x" ,  123 );
setcookie ( "z" ,  'abc' ,time()+100);
//setcookie ( "y" ,  array('y1'=>2,'y2'=>array(3,45)));


//cookie是这样删除的，利用生命周期删除。下面一篇课程会说到生命周期

//并且要刷新一下，才能看到删除效果。因为：这是要求浏览器删除cookie
//本次浏览器刷新后，服务端php发布了命令，让浏览器删除cookie
//之后刷新结束，浏览器执行了这个命令，但是还没有传到服务端
//之后，再刷新，浏览器才把，刚才执行完的命令结果，又提交到服务端
setcookie ( "z" ,  'abc' ,time()-1);

//输出$_COOKIE数组查看						
//取值之前可以由输出
echo "<pre>";

print_r($_COOKIE);
echo "<br>";
echo $_COOKIE['x'];


//////////////////////////////////////////////////
//
// 之后，请把cookie赋值行，注释掉，可以发现还能输出，说明是超全局变量。
// 重写一个页面，仅获得cookie，也可以，说明在同一网站下，可以跨页面 
// 请在setcookie()前进行输出，看看会发生什么 
//
/////////////////////////////////////////////////
</textarea>
<br>
之后，请把cookie赋值行，注释掉，可以发现还能输出，说明是超全局变量。<br>
并且可以重写一个页面，仅获得cookie，也可以，说明在同一网站下，可以跨页面<br>
请在setcookie()前进行输出，看看会发生什么 
	<br></span>
			
		<b class="hs_2">5)从保存的生命周期看</b>：它们都有过期时间。都可以设置过期时间。默认是浏览器关闭。除了在运行程序中修改，也可以在php.ini中修改<br>
			session生命周期：为所有session同样，<br>
			cookie生命周期：可以为每个cookie的值设置不同<br>

		<span class="hs_2_son"><br>
		(1)session生命周期：<br>
			<textarea>
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误
//ini_set("memory_limit", 2048576000);//设置内存最大字节数
//ini_set("max_execution_time", 24000);//设置执行时间为24000
//ini_set('default_socket_timeout',24000);//就是设置default_socket_timeout这个配置参

//设置session生命周期为10秒
$expire=10;
ini_set('session.gc_maxlifetime', $expire);
session_set_cookie_params($expire); 

//开启session
//在这之前不能有任何输出！！包括空格和html
session_start();

//给session赋值。可以赋数组值。本身好像一个数组一样
$_SESSION['a']=1;
$_SESSION['b']=array('b1'=>2,'b2'=>array(3,45));


//输出时间
echo date("Y-m-d H:i:s");
echo "<br>";

//输出$_SESSION数组查看
echo "<pre>";								 
print_r($_SESSION);
echo "<br>";
echo $_SESSION['b']['b2'][1];
//////////////////////////////////////////////////
//
// 之后，请把session赋值行，注释掉，看什么时候输出不了。
//
/////////////////////////////////////////////////
			</textarea>
<br>
之后，请把session赋值行，注释掉，看什么时候输出不了。
<br>
<br>

		(2)cookie生命周期：<br>
			<textarea>
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误
//ini_set("memory_limit", 2048576000);//设置内存最大字节数
//ini_set("max_execution_time", 24000);//设置执行时间为24000
//ini_set('default_socket_timeout',24000);//就是设置default_socket_timeout这个配置参

//给cookie赋值。赋的值，不能是数组，只能是字符串或者数字。本身则像一个一维数组
//////////////////////第3个参数是生命周期。秒

$expire=10;
$expire2=20;
setcookie ( "x" ,  123 ,time()+$expire);
setcookie ( "z" ,  456 ,time()+$expire2);
//setcookie ( "y" ,  array('y1'=>2,'y2'=>array(3,45)));

//输出时间
echo date("Y-m-d H:i:s");
echo "<br>";

//输出$_COOKIE数组查看
echo "<pre>";								 
print_r($_COOKIE);

//////////////////////////////////////////////////
//
// 之后，请把cookie赋值行，注释掉，看什么时候输出不了。
//
/////////////////////////////////////////////////
		</textarea>
<br>
之后，请把cookie赋值行，注释掉，看什么时候输出不了。
<br>
			<br>
		</span>

		<b class="b2">6)从保存位置看</b>：它们默认都是保存在硬盘上。可以通过php.ini等设置，保存到数据库等地方<br>
			session保存在服务器的硬盘，<br>
			cookie保存在客户电脑的硬盘上<br>
		<b class="b2">7)从保存大小限制看</b>：<br>
			session文件的保存，通常无限的<br>
			cookie文件的保存，通常为4K<br>
		<b class="hs_2">8)从可操作的语言看。</b>：<br>
			session文件：只有php可以操作<br>
			cookie文件：php和javascript都可以操作。所以cookie内容，可以作为这两个语言分享数据的地方<br>
			<span class="hs_2_son"><br>
			cookie可操作的语言测试：<br>
			<textarea>
<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误
//ini_set("memory_limit", 2048576000);//设置内存最大字节数
//ini_set("max_execution_time", 24000);//设置执行时间为24000
//ini_set('default_socket_timeout',24000);//就是设置default_socket_timeout这个配置参

//////////当前服务端，通过setcookie()要求：浏览器修改cookie
/////////但当前服务端已经取得的cookie值，是刚才浏览器请求时，发送过来的值。
/////////所以，当前使用setcookie()，并不能修改服务端现有的cookie值

///////////////////
//
// 页面显示完后，点击设置cookie按钮，再刷新，就能明白上述话的意思
//
///////////////////

setcookie ( "xyz" ,  "abc12345");
?>
<script>
/////////////////////javascript方式，设置浏览器的cookie
////////////////////jquery，则可使用cookie插件
function SetCookie(name,value)//两个参数，一个是cookie的名子，一个是值
{
    var Days = 30; //此 cookie 将被保存 30 天
    var exp  = new Date();    //new Date("December 31, 9998");
    exp.setTime(exp.getTime() + Days*24*60*60*1000);
    document.cookie = name + "="+ escape (value) + ";expires=" + exp.toGMTString();
}
function getCookie(name)//取cookies函数        
{
    var arr = document.cookie.match(new RegExp("(^| )"+name+"=([^;]*)(;|$)"));
     if(arr != null) return unescape(arr[2]); return null;

}
function delCookie(name)//删除cookie
{
    var exp = new Date();
    exp.setTime(exp.getTime() - 1);
    var cval=getCookie(name);
    if(cval!=null) document.cookie= name + "="+cval+";expires="+exp.toGMTString();
}


</script>
<input type="button" value="设置cookie" onclick="javascript:SetCookie('xyz','abc')">


<input type="button" value="获得cookie" onclick="javascript:alert(getCookie('xyz'))">

<?php
echo "<pre>";
print_r($_COOKIE);
			</textarea>

			<br></span>


		<b class="hs_2">9)从操作的锁定看</b>：<br>
			session操作，是独占性访问。当前浏览器只要有一个页面(包括该页面的超链接，点击弹出的页面)，在使用session，则当前浏览器的其他页面，如果也使用session，就要等待，直至第一个页面访问结束<br>
			cookie操作，非独占性访问<br>

		<span class="hs_2_son">
		<br>
		session独占性测试：<br>
			<textarea>
<?php
	//第一个页面
	session_start();
	$_SESSION['username']="张三";
	sleep(15);
?>


<?php
	//第二个页面。在第一个页面刷新后，15秒之内，访问
	session_start();
	echo "<pre>";
	print_r($_SESSION);
?>
			</textarea>

		<br>
		</span>
		<b class="b2">10)从安全性看</b>：<br>
			通常session安全一点，因为保存在服务端，客户端无法看见保存的内容<br>
			而cookie差一点，因为保存在客户端，可以被看见，容易被篡改。在浏览器地址栏输入：javascript:alert(document.cookie);回车<br>
			但当知道了其运行机制，就明白了，sesssion安全是受限于cookie中session_id不泄露为前提的<br>
	</li>

	<li class="homework">
		作业：<br>
		1.用php将多维数组保存到session中，然后再读取出来<br>
		2.用php将多维数组保存到cookie中，然后再读取出来<br>
		3.上网查找：session.gc_maxlifetime/session.gc_probability/session.gc_divisor 三者间关系。并说明：取不到某个session值，是否代表该session文件删除了，为什么？<br>
		4.扩展题：用已学的知识，写函数，模拟整个session，并可替代session存储：思路：想好键名(如：simulation_id) / 判断浏览器提交来的$_COOKIE中有没有这个键名 / 没有就创建一个唯一号，并作为文件名，可接收一些信息(序列化)，然后保存到该文件 / 最后将这个唯一号，作为cookie键名simulation_id的值<br>
		
		<span class="answer">答案</span>：<br>
		<textarea>
1.略
2.略
3.略
4.
//模拟session函数
//$name 读取名称。如果不填，返回全部数组
//$value 需要赋的值。如果不填是读取，否则是赋值
function simulation_session($name=null,$value=null){
	//键名。模拟session用
	$simulation_id='simulation_id';


	//在网站根目录，建立存放模拟session存放的目录
	$simulationDir=$_SERVER["DOCUMENT_ROOT"]."/simulation_id";
	if(!is_dir($simulationDir)){
		@mkdir( $simulationDir,0777,true);
	}
		
	//如果cookie中没有模拟session标志。则取唯一值，赋值给cookie
	if(!isset($_COOKIE[$simulation_id])){
		//唯一值
		$simulation_value=md5(uniqid($_SERVER['HTTP_HOST'],true));
		setcookie ( $simulation_id,$simulation_value);
	}else{
		$simulation_value=$_COOKIE[$simulation_id];
	}

	//模拟session的文件本身
	$simulationPath=$simulationDir."/".$simulation_value;
	//如果是取值
	if($value===null ){
		//读取 模拟session的文件内容。并反序列化
		if(is_file($simulationPath)){
			$tmp=@unserialize(@file_get_contents($simulationPath));
			$tmp=is_array($tmp)?$tmp:array();
			if($name===null){//读取所有
				return $tmp;
			}else if(isset($tmp[$name])){
				return $tmp[$name];
			}else{
				return null;
			}
		}else{
			return null;
		}
	}else {//保存
		$tmp=@unserialize(@file_get_contents($simulationPath));
		$tmp=is_array($tmp)?$tmp:array();
		$tmp[$name]=$value;
		file_put_contents($simulationPath,serialize($tmp));
		return true;
	}
}

//赋值
simulation_session("kkk",'abc');
simulation_session("kkk2",array(1,23,4));


echo "<pre>";
//读取
echo simulation_session("kkk");
echo "<br>";

//读取所有
print_r(simulation_session());
print_r($_COOKIE);
exit;
		</textarea>
	</li>

	</ul>
</div>


<div id="bio">
	<li>
		<h1>
			<a href="###" style="cursor:point;text-decoration:none;" class="hs_1">第十一部分 图像处理</a>
		</h1>
	</li>

	<ul>
	<li>
	<pre>
php处理图像，主要使用gd库
在PHP5 中，动态图象的处理要比以前容易得多。
PHP5 在php.ini 文件中包含了GD 扩展包，只需去掉GD 扩展包的相应注释就可以正常使用了。
PHP5 包含的GD 库正是升级的GD2 库，其中包含支持真彩图像处理的一些有用的JPG 功能。
一般生成的图形，通过PHP 的文档格式存放，但可以通过HTML 的图片插入方式SRC来直接获取动态图形。比如，验证码、水印、微缩图等。

<b>创建图像(一):</b>
创建图像的一般流程：
1).设定标头，告诉浏览器你要生成的MIME 类型。
2).创建一个图像区域，以后的操作都将基于此图像区域。
3).在空白图像区域绘制填充背景。
4).在背景上绘制图形轮廓输入文本。
5).输出最终图形。
6).清除所有资源。
7).其他页面调用图像。

<textarea>
<?php
//设定标头指定MIME 输出类型	
header('Content-Type: image/png');

//创建一个空白的图像区域
$im = imagecreate(200,200);

$blue = imagecolorallocate($im,0,102,255);
//imagefill($im, 0, 0,$blue);	//在空白图像区域绘制填充背景
$white = imagecolorallocate($im,255,255,255);

//在背景上绘制图形轮廓输入文本
imageline($im, 0, 0, 200, 200, $white);	
imageline($im, 200, 0, 0, 200, $white);	
imagestring($im, 5, 80, 20, "Mr.Lee", $white);

//输出最终图形
imagepng($im);

//清除所有资源
imagedestroy($im);
?>
</textarea>	

<b>创建图像(二)：</b>
1、建立新图：
	int imagecreate(int x_size, int y_size); 
	说明:本函数用来建立一张全空的图形。参数 x_size、y_size 为图形的尺寸，单位为像素 (pixel)。
	例: $im = imagecreate(400,100);

	匹配颜色：
	int imagecolorallocate(int im, int red, int green, int blue);
	说明:本函数用来匹配图形的颜色，供其它绘图函数使用。参数 im 表示图形的 handle。参数 red、green、blue 是色彩三原色。
	例: $yellow = ImageColorAllocate($im, 255,255,128);


2、header
	header("Content-type: image/gif");//输出gif图像
	header("Content-type: image/jpeg");//输出jpeg图像
	header("Content-type: image/png");//输出png图像输出字符

	int imagechar(int im, int font, int x, int y, string c, int col);
	说明: 本函数用来书写字符。原点坐标 (0,0) 为图片的左上角，参数 font 表示字体的大小，从最小的 1 起，参数 x、y 是写入字元的坐标值，参数 c 为欲写出的字元，参数 col 为字的颜色。参数 im 表示图形的 handle。
	例:
	imagechar($im,4,1,1,’A’,$white);

3、输出字符串
	int imagestring(int im, int font, int x, int y, string s, int col);
	说明:本函数在图片上绘出字符串。参数 font 为字形，设为 1 到 5 表示使用内定字形。参数 x、y 为字串起点坐标。字符串的内容放在参数 s 上。参数 col 表示字串的颜色。
	例:imagestring($im, 5, 4, 10, "Graph TEST!", $white);

	绘制矩形
	imageRectangle($im,x1,y1,x2,y2,$color);
	说明：在图片上绘出矩形。参数 x1、y1 及 x2、y2 分别为矩形对角线的坐标。参数 col 表示矩形边框的颜色。
	例:imageRectangle($im.10,10,40,40,$white);

4、矩形区域着色
	int imagefilledrectangle(im, x1, y1, x2, y2, col); 
	说明：将图片的封闭矩形区域着色。参数 x1、y1 及 x2、y2 分别为矩形对角线的坐标。参数 col 表示欲涂上的颜色。
	例:imagefilledrectangle($im, 10,10, 40, 40, $back);

5、绘制弧线
	int imagearc(im, cx, cy, w, h, s, e, col); 

	说明：用来画弧线。原点坐标 (0,0) 为图片的左上角，参数 cx、c
	y 为椭圆心坐标，参数 w 为水平轴长，参数 h 为垂直轴长，参数 
	s 及 e 分别为起始角与结束角，参数 col 为弧线的颜色。参数 im表示图形的 handle。
	例:imagearc($im, 200, 15, 20, 20, 35, 190, $white);

6、绘制直线
	imageline ($im, x1, y1, x2, y2, color)
	说明：在图形上画出一条实线。从 x1、y1 连接到 x2、y2，原点(0,0) 为图形的左上角。参数 col 为实线的颜色。 
	例:imageline($im, 1, 1, 350, 25, $yellow);
	绘制点
	int imagesetpixel($im,x, y, col);

	说明：可在图片上绘出一点。参数 x、y 为欲绘点的坐标，参数col 表示该点的颜色。
	例:imagesetpixel($im,300,50,$yellow); 


创建图像(二)最终创建的图像代码：
<textarea>
<?php
header('Content-Type: image/gif');		
$im = imagecreate(400,100);
//创建一个空白的图像区域

$black =ImageColorAllocate($im,0,0,0);		
$yellow =ImageColorAllocate($im, 255, 255,128);

//在空白图像区域绘制填充背景		
$white = ImageColorAllocate($im,255,255,255);

imageline($im, 1, 1, 350, 25, $yellow);
imagearc($im, 200, 15, 20, 20,35,190, $white);	
imagestring($im, 5, 4, 10, "Mr.Lee", $white);
//在背景上绘制图形轮廓输入文本

ImageGif($im);		//输出最终图形
ImageDestroy($im);		//清除所有资源
?>
</textarea>

<b>创建图像(三)书写验证码：</b>
<textarea>
<?php		
session_start();//生成验证码图片

Header("Content-type:image/PNG");

$im = imagecreate(44, 18);// 画一张指定宽高的图片

$back = imagecolorallocate($im, 255, 255, 255);
//把背景颜色填充到刚刚画出来的图片中

$vcodes = "";		// srand((double)microtime() * 1000000);

//生成4位数字
for($i = 0; $i < 4; $i++){			
	$font = imagecolorallocate($im, rand(0, 255), rand(0, 255), rand(0, 255)); // 生成随机颜色
	$authnum = rand(1, 9);
	$vcodes .= $authnum;
	imagestring($im, 5, 2 + $i * 10, 1, $authnum,$font);
}

$_SESSION['VCODE'] = $vcodes;

for($i=0;$i<100;$i++) { 
	//加入干扰象素
	$randcolor = imagecolorallocate($im, rand(0, 255), rand(0,255), rand(0, 255));
	imagesetpixel($im, rand(0,44), rand(0,18),$randcolor); 
	//imagesetpixel($im, rand()%70, rand()%30,$randcolor); 
	// 画像素点函数

}
imagepng($im);		
imagedestroy($im);
?>
</textarea>


<b style="color:red">创建图像(四)中文验证码：</b>
<textarea>
<?php		
session_start();//生成验证码图片

Header("Content-type:image/PNG");

//定义宽高
$width=100;
$height=30;

//定义生成数量
$num=4;

//每个文字宽度
$font_width=floor($width/($num+1));//多加1个文字，为了 left和right能有空，好看

//定义字体！！！需要准备好中文字体文件
$font=dirname(__FILE__)."/china.ttf";
//字体大小
$fontSize=13;


//字符串范围
$strList="定义很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字";




//画一张指定宽高的图片
$im = imagecreate($width, $height);

//定义背景颜色	//把背景颜色填充到刚刚画出来的图片中
$back = imagecolorallocate($im, 255, 255, 255);

//生成每个文字
for($i = 0; $i < $num; $i++){			
	//定义颜色
	$fontColor = imagecolorallocate($im, rand(0, 255), rand(0, 255), rand(0, 255));

	//随机获得文字
	$n=rand(0, mb_strlen($strList,'utf-8'));
	$authnum = mb_substr($strList,$n,1,'utf-8');

	//角度范围
	$fontAngle=rand(-20,20);

	$boxSize=imagettfbbox( $fontSize , $fontAngle, $font ,$authnum );//文字整体大小
	//$fontX=abs($boxSize[0]-$boxSize[2]);//文字宽度
	$fontY=abs($boxSize[1]-$boxSize[7]);//文字高度

	$x=$font_width*$i+floor($font_width/2);//左下角x坐标。增加半个文字位置
	$y= ($height - $fontY)/2 +$fontY;//左下角y坐标

	//写字
	imagettftext($im, $fontSize, $fontAngle, $x, $y, $fontColor, $font, $authnum);

	$vcodes .= $authnum;//给session用
}


//干扰素密度
$pixelLength=40/3000*($width*$height);
for($i=0;$i<$pixelLength;$i++) { 
	//定义干扰象素颜色
	$randcolor = imagecolorallocate($im, rand(0, 255),rand(0,255), rand(0, 255));

	// 画像素点函数
	imagesetpixel($im, rand(0,$width), rand(0,$height),$randcolor); 
}

imagepng($im);		
imagedestroy($im);

//写到session
$_SESSION['VCODE'] = md5($vcodes);
?>

</textarea>


<b style="color:red">创建图像(五)文字水印：</b>
<textarea>
<?php
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息

/*文字水印*/

//原图路径
$filePath=dirname(__FILE__)."/b.jpg";
//原图后缀
$suffix=strtolower(substr($filePath, -3));

//读取图片，变成资源
if($suffix=='png'){
	$im = imagecreatefrompng($filePath);
}elseif($suffix=='jpg'){
	$im = imagecreatefromjpeg($filePath);
}elseif($suffix=='gif'){
	$im = imagecreatefromgif($filePath);
}else{
	exit('imgTypeErr');
}

//文字
$authnum="文字水印";
//定义字体！！！需要准备好中文字体文件
$font=dirname(__FILE__)."/china.ttf";
//字体大小
$fontSize=13;
//角度
$fontAngle=0;
//颜色
$fontColor=imagecolorallocate($im, 255, 0, 0);

//文字整体大小
$boxSize=imagettfbbox( $fontSize , $fontAngle, $font ,$authnum);
$fontX=abs($boxSize[0]-$boxSize[2]);//文字宽度
$fontY=abs($boxSize[1]-$boxSize[7]);//文字高度

//位置：左上角
$x=0;
$y=$fontY;

//右下角
/*

$x= imagesx($im) - $fontX;
$y= imagesy($im);//获得图片高度
*/



//写字
imagettftext($im, $fontSize, $fontAngle, $x, $y, $fontColor, $font, $authnum);
//imagestring($im, 5, 1, 1, $authnum,$fontColor);

//预备：新图路径
$filePathNew=dirname(__FILE__)."/b1.".$suffix;

//输出 处理完的图像资源，到文件
if($suffix=="jpg"){
	Imagejpeg($im,$filePathNew,100);
}elseif($suffix=="png"){
	Imagepng($im,$filePathNew);
}elseif($suffix=="gif"){
	Imagegif($im,$filePathNew);
}

header("Content-type:image/".$suffix);
//显示图像
if($suffix=="jpg"){
	Imagejpeg($im);
}elseif($suffix=="png"){
	Imagepng($im);
}elseif($suffix=="gif"){
	Imagegif($im);
}



?>
</textarea>

<b style="color:red">创建图像(六)图片水印：</b>
<textarea>
<?php
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息

/*图片水印*/

//原图路径
$filePath=dirname(__FILE__)."/b.jpg";
//原图后缀
$suffix=strtolower(substr($filePath, -3));

//读取图片，变成资源
if($suffix=='png'){
	$im = imagecreatefrompng($filePath);
}elseif($suffix=='jpg'){
	$im = imagecreatefromjpeg($filePath);
}elseif($suffix=='gif'){
	$im = imagecreatefromgif($filePath);
}else{
	exit('imgTypeErr');
}


//水印图片路径
$filePath2=dirname(__FILE__)."/sy.png";
//水印图片后缀
$suffix2=strtolower(substr($filePath2, -3));

//读取水印图片，变成资源
if($suffix2=='png'){
	$im2 = imagecreatefrompng($filePath2);
}elseif($suffix2=='jpg'){
	$im2 = imagecreatefromjpeg($filePath2);
}elseif($suffix2=='gif'){
	$im2 = imagecreatefromgif($filePath2);
}else{
	exit('imgTypeErr2');
}
//水印图片宽高
$w=imagesx($im2) ;
$h=imagesy($im2) ;

// 重采样拷贝部分图像并调整大小
////目标图像，源图像 / 目标x，目标y/ 源x，源y /目标宽度，目标高度/ 源宽度，源高度
ImageCopyResampled(
				$im,
				$im2,
				0,
				0,
				0,
				0,
				$w,//或者除以2，变小点
				$h,//或者除以2
				$w,
				$h
				);

//预备：新图路径
$filePathNew=dirname(__FILE__)."/b1.".$suffix;

//输出 处理完的图像资源，到文件
if($suffix=="jpg"){
	Imagejpeg($im,$filePathNew,100);
}elseif($suffix=="png"){
	Imagepng($im,$filePathNew);
}elseif($suffix=="gif"){
	Imagegif($im,$filePathNew);
}

header("Content-type:image/".$suffix);
//显示图像
if($suffix=="jpg"){
	Imagejpeg($im);
}elseif($suffix=="png"){
	Imagepng($im);
}elseif($suffix=="gif"){
	Imagegif($im);
}



?>
</textarea>


<b style="color:red">创建图像(七)缩略图：</b>
<textarea>
<?php
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息

/*缩略图*/
$imgFilePath1=dirname(__FILE__)."/x.png";//448*448 //原图
$imgFilePath2=dirname(__FILE__)."/x2.png"; //新图：预备缩略图。若png，则背景透明
$nw=200;//新图宽
$nh=300;//新图高

//创建缩略图
$im2=_createImg($imgFilePath1,$imgFilePath2,$nw,$nh);

/////////////////////////////////
//
//	显示看一下，测使用
//	可以不用！！！！！
//
////////////////////////////////////
$suffix2=strtolower(substr($imgFilePath2, -3));
header("Content-type:image/".$suffix2);
//显示图像
if($suffix2=="jpg"){
	Imagejpeg($im2);
}elseif($suffix2=="png"){
	Imagepng($im2);
}elseif($suffix2=="gif"){
	Imagegif($im2);
}


//创建缩略图
/*
$imgFilePath1：原图路径
$imgFilePath2：新图路径。缩略图 预备
$nw：新图宽度
$nh：新图高度
*/
function _createImg($imgFilePath1,$imgFilePath2,$nw,$nh){
	//读取原图 资源
	//原图后缀
	$suffix=strtolower(substr($imgFilePath1, -3));
	if($suffix=='png'){
		$im1 = imagecreatefrompng($imgFilePath1);
	}elseif($suffix=='jpg'){
		$im1 = imagecreatefromjpeg($imgFilePath1);
	}elseif($suffix=='gif'){
		$im1 = imagecreatefromgif($imgFilePath1);
	}else{
		exit('imgTypeErr');
	}
	$w=imagesx($im1) ;//原图宽度
	$h=imagesy($im1) ;//原图高度

	//创建新图 资源
	$im2=_createCandle($nw,$nh);
	//新图后缀
	$suffix2=strtolower(substr($imgFilePath2, -3));
	
	//获得 新的宽高/位置
	list($nw2,$nh2,$nl2,$nt2)=_getWHscaling($w,$h,$nw,$nh);

	/* 若使用原始值，会变形
	$nw2=$nw;
	$nh2=$nh;
	$nl2=0;
	$nt2=0;
	*/
		
	// 重采样拷贝部分图像并调整大小
	////目标图像，源图像 / 目标x，目标y/ 源x，源y /目标宽度，目标高度/ 源宽度，源高度
	ImageCopyResized(
						$im2,$im1,
						$nl2,$nt2,
						0,0,
						$nw2,$nh2,
						$w,$h
					);
	
	//输出 处理完的图像资源，到文件
	if($suffix2=="jpg"){
		Imagejpeg($im2,$imgFilePath2,100);
	}elseif($suffix2=="png"){
		Imagepng($im2,$imgFilePath2);
	}elseif($suffix2=="gif"){
		Imagegif($im2,$imgFilePath2);
	}

	return $im2;
}

//创建画布
function _createCandle($w,$h) {
	//新建一个真彩色图像。返回资源对象
	$c=imagecreatetruecolor($w, $h);

	//设定图像的混色模式
	imagealphablending($c, true);

	//设置透明通道
	imagesavealpha($c, true);

	//设置透明色
	$trans_colour = imagecolorallocatealpha($c, 0, 0, 0, 127);

	//用透明色，填充
	imagefill($c, 0, 0, $trans_colour);

	Return $c;
}



/**
* @计算宽高/位置比例
*/
function _getWHscaling($fromW,$fromH,$toW,$toH) {
	$wScaling=$toW/$fromW;//宽比例
	$hScaling=$toH/$fromH;//高比例

	$scaling=1;//缩放的比例

	$nl=0;//新的left
	$nt=0;//新的top

	//宽、高都放大 ,或者 宽、高都缩小
	if( 
		($wScaling >= 1 && $hScaling >= 1) 
		|| ($wScaling <= 1 && $hScaling <= 1)
		){ 

		//使用小比例作为标准
		$scaling=min($wScaling,$hScaling);

	}elseif($wScaling >= 1){//只有宽放大。使用小比例作为标准

		$scaling=$hScaling;

	}elseif($hScaling >= 1){//只有高放大。使用小比例作为标准

		$scaling=$wScaling;

	}

	//获得新的宽高
	 $nw = $scaling * $fromW;
	 $nh = $scaling * $fromH;

	//让宽高居中
	//如果新的宽(40)，小于要求的宽度(100)
	//那么，新的位置left，应当在 (100-40)/2=30 
	//才能让新位置，居中
	if($nw < $toW){
		$nl=($toW-$nw)/2;
	}

	if($nh < $toH){
		$nt=($toH-$nh)/2;
	}


	Return array($nw,$nh,$nl,$nt);
}

?>
</textarea>

<b style="color:red">创建图像(八)预览图像并剪裁：</b>

img_cut.html
<textarea>
<html>  
        <head>  
<style>
/*
	选区层的父容器，
	！！！相对定位必须

	可根据需要修改宽高/边框
*/
.middClass{
	/*
	border:1px solid  #c0c0c0;
	width:200px;
	height:200px;
	*/
	position:relative;

	background:#ffffff;
}

/*
	选区层
	可根据需要修改宽高
	！！！绝对定位必须
	！！！要设置z轴
	！！！要透明度

	！！注意，选区层：使用绝对定位
	请为其的父元素，设置相对定位
	这样 的坐标系，就是它的父元素
	否则：坐标系：是整个文档(document)！！
*/
.magnifierClass{
	position:absolute;
	left:0px;
	top:0px;
	width:80px;
	height:80px;
	background:yellow;
	z-index:100;

	opacity:0.5;
	filter:alpha(opacity=50);

	cursor:move     
}

</style>


<script src="./jquery-1.7.1.js"></script>

<script type="text/javascript">  
/*
以下为图片预览代码
*/
//使用IE条件注释来判断是否IE6，通过判断userAgent不一定准确
 if (document.all) document.write('<!--[if lte IE 6]><script type="text/javascript">window.ie6= true<\/script><![endif]-->');
 // var ie6 = /msie 6/i.test(navigator.userAgent);//不推荐，有些系统的ie6 userAgent会是IE7或者IE8
 function file_change(picId,fileId) {
  var pic = document.getElementById(picId);
  var file = document.getElementById(fileId);
  if(window.FileReader){//chrome,firefox7+,opera,IE10,IE9，IE9也可以用滤镜来实现
   oFReader = new FileReader();
   oFReader.readAsDataURL(file.files[0]);
   oFReader.onload = function (oFREvent) {pic.src = oFREvent.target.result;};  
  }
  else if (document.all) {//IE8-
   file.select();
   var reallocalpath = document.selection.createRange().text//IE下获取实际的本地文件路径
   if (window.ie6) pic.src = reallocalpath; //IE6浏览器设置img的src为本地路径可以直接显示图片
   else { //非IE6版本的IE由于安全问题直接设置img的src无法显示本地图片，但是可以通过滤镜来实现，IE10浏览器不支持滤镜，需要用FileReader来实现，所以注意判断FileReader先
    pic.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod='image',src=\"" + reallocalpath + "\")";
    pic.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';//设置img的src为base64编码的透明图片，要不会显示红xx
   }
  }
  else if (file.files) {//firefox6-
   if (file.files.item(0)) {
    url = file.files.item(0).getAsDataURL();
    pic.src = url;
   }
  }


 }
 /*
图片预览代码结束
 */


//移动参数
var mox,mnx,moy,mny;

$(document).ready(
	function (){
		//绑定文件上传框，change事件
		$("#imgFile").bind(
			"change",
			function (){
				//上传框内容变化，处理函数
				file_change('imgExample','imgFile')

				
				//将选区，宽高还原
				$(".magnifierClass").css({"width": "80px"})
				$(".magnifierClass").css({"height": "80px"})
			}
		)

		/*
			选区框 鼠标点击
		*/
		$(".magnifierClass").bind(
			"mousedown",
			function (event){
				//改变 父容器大小 和 选区大小
				change_divSize();

				//获得当前鼠标位置
				mox=event.pageX;
				moy=event.pageY;

				/*
					父容器上鼠标移动
				*/
				$(".middClass").bind(
					"mousemove",
					function (event){
						mnx=event.pageX
						mny=event.pageY

						var xx=parseInt($(".magnifierClass").css('left'))+mnx-mox;
						var yy=parseInt($(".magnifierClass").css('top'))+mny-moy;

						//验证是否超出范围
						//不能为负值
						xx=Math.max(xx,0);
						yy=Math.max(yy,0);

						//不能超出右边
						xx=Math.min( 
									xx,
									parseInt($(".middClass").css('width'))-
									parseInt($(".magnifierClass").css('width'))
								);

						yy=Math.min( 
									yy,
									parseInt($(".middClass").css('height'))-
									parseInt($(".magnifierClass").css('height'))
									);

							//移动 选区框
							$(".magnifierClass").css({"left":xx+"px","top":yy+"px"})
										
							mox=mnx;
							moy=mny;

						}
					)
			}
		);
		
		//鼠标弹起，解除绑定。
		$(document).bind(
			"mouseup",
			function (){
				$(".middClass").unbind( "mousemove" )

				//并将 选择框，位置等参数 记录
				$("#selectPosition").val(
										parseInt($(".magnifierClass").css("left"))+
										","+
										parseInt($(".magnifierClass").css("top"))+	","+
										parseInt($(".magnifierClass").css("width"))+	","+
										parseInt($(".magnifierClass").css("height"))
										)
			}
		)
	}
)


//改变 父容器大小 和 选区大小
function change_divSize(){
	 //改变父容器宽高 = 图片宽高
	$(".middClass").css({"width":$("#imgExample").width(),"height":$("#imgExample").height()})

	//若预览图 小于 选区，则改变选区 为预览图1半
	if(
		$("#imgExample").width()<$(".magnifierClass").width() 
		|| $("#imgExample").height()<$(".magnifierClass").height()

	){
		var tmp_w=parseInt($("#imgExample").width()/2);
		var tmp_h=parseInt($("#imgExample").height()/2);

		$(".magnifierClass").css({"width": Math.min(tmp_w,tmp_h)+"px"})
		$(".magnifierClass").css({"height": Math.min(tmp_w,tmp_h)+"px"})
	}
}
</script>  
</head>  

<body>
<form method="post" enctype="multipart/form-data" action="./file_upload.php">
	<input type="file" id="imgFile" name="imgFile"/>
	<br>

	<input id="selectPosition" name="selectPosition">
	<br>
	<input type="submit">
</form>

	<div class="middClass">
		<img id="imgExample">
		<div class="magnifierClass"></div>
	</div>
</body>  

    </html>  


</textarea>

file_upload.php
<textarea>
<?php
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息

if(!empty($_FILES)){
	//作为一个程序员开始处理

	//如果没有错误
	if($_FILES['imgFile']['error']==0){

		//通过文件后缀，判断是否允许上传的文件
		$suffix=substr(strrchr($_FILES['imgFile']['name'],'.'),1); //还能用什么方式？
		if(!in_array($suffix,array('jpg','png','gif','zip','rar','xls','doc'))){
			exit("该文件类型不允许上传！");
		}

		//建立一个文件夹，为了把上传文件真正放到该位置。
		$fileDir=dirname(__FILE__)."/upload/".date("Y-m-d");//组织好想要的文件夹名称。当前以日期命名。可以以登录用户的手机号，每个用户文件传到自己文件夹。或者其他命名规则
		@mkdir($fileDir,0777,true);//递归建立文件夹
		//判断文件夹是否创建成功
		if(!is_dir($fileDir)){
			exit("建立文件夹失败！");
		}

		//重新组织文件名称。通常不会使用用户上传的文件名。
		//为了安全和兼容，会使用英文和数字。并要唯一
		//用户原文件名，如需要，会保存到数据库
		$fileName=md5(uniqid('', true).$_FILES['imgFile']['name']);
		$fileName.='.'.$suffix;//并接上后缀

		//拼装成全路径
		$filePath=$fileDir.'/'.$fileName;
		//echo $filePath;exit;

		//最后操作：将临时文件，移动到自己想要地方
		if(move_uploaded_file($_FILES['imgFile']['tmp_name'],$filePath)==true){
			//echo "上传成功";

		}else{
			echo "上传失败";
		}


		
	}else{
		echo "上传错误：".$_FILES['imgFile']['error'];
	}
}





/*缩略图*/
$imgFilePath1=$filePath; //原图
$imgFilePath2=dirname(__FILE__)."/x2.png"; //新图：预备缩略图。若png，则背景透明


//读取原图 资源
//原图后缀
$suffix=strtolower(substr($imgFilePath1, -3));
if($suffix=='png'){
	$im1 = imagecreatefrompng($imgFilePath1);
}elseif($suffix=='jpg'){
	$im1 = imagecreatefromjpeg($imgFilePath1);
}elseif($suffix=='gif'){
	$im1 = imagecreatefromgif($imgFilePath1);
}else{
	exit('imgTypeErr');
}

//创建新图

//[selectPosition] => 238,191,80,80
$selectPosition=explode(",",$_POST['selectPosition']);

$nw=$selectPosition[2];//新图宽
$nh=$selectPosition[3];//新图高

$ox=$selectPosition[0];//原图x
$oy=$selectPosition[1];//原图y

$im2=_createCandle($nw,$nh);

// 重采样拷贝部分图像并调整大小
////目标图像，源图像 / 目标x，目标y/ 源x，源y /目标宽度，目标高度/ 源宽度，源高度
ImageCopyResized(
					$im2,$im1,
					0,0,
					$ox,$oy,
					$nw,$nh,
					$nw,$nh
				);


//输出 处理完的图像资源，到文件
$suffix2=strtolower(substr($imgFilePath2, -3));
if($suffix2=="jpg"){
	Imagejpeg($im2,$imgFilePath2,100);
}elseif($suffix2=="png"){
	Imagepng($im2,$imgFilePath2);
}elseif($suffix2=="gif"){
	Imagegif($im2,$imgFilePath2);
}
/////////////////////////////////
//
//	显示看一下，测使用
//	可以不用！！！！！
//
////////////////////////////////////
header("Content-type:image/".$suffix2);
//显示图像
if($suffix2=="jpg"){
	Imagejpeg($im2);
}elseif($suffix2=="png"){
	Imagepng($im2);
}elseif($suffix2=="gif"){
	Imagegif($im2);
}

//创建画布
function _createCandle($w,$h) {
	//新建一个真彩色图像。返回资源对象
	$c=imagecreatetruecolor($w, $h);

	//设定图像的混色模式
	imagealphablending($c, true);

	//设置透明通道
	imagesavealpha($c, true);

	//设置透明色
	$trans_colour = imagecolorallocatealpha($c, 0, 0, 0, 127);

	//用透明色，填充
	imagefill($c, 0, 0, $trans_colour);

	Return $c;
}


?>
           
</textarea>

<b style="color:red">创建图像(九)进阶图像处理：</b>
<textarea>
<?php
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误

//原图路径
$filePath=dirname(__FILE__)."/a.png";
//原图后缀
$suffix=strtolower(substr($filePath, -3));

//预备：新图路径
$filePathNew=dirname(__FILE__)."/a1.".$suffix;

//创建图片处理配置
$config=array();

//获得图片资源
if($suffix=='png'){
	$config['source'] = imagecreatefrompng($filePath);
}elseif($suffix=='jpg'){
	$config['source'] = imagecreatefromjpeg($filePath);
}elseif($suffix=='gif'){
	$config['source'] = imagecreatefromgif($filePath);
}else{
	exit('imgTypeErr');
}

$config['w']=imagesx($config['source']);//获得 原宽/高
$config['h']=imagesy($config['source']);

$config['nw']=111;//新的宽高
$config['nh']=47;

$config['mouseAngle']=0; //旋转图像的度数
$config['isOverTurnH']=0;//是否水平翻转

$config['l']=0;//新图在背景图上 位置
$config['t']=0;

//创建背景图
$candle=_createCandle(300,300);

//在背景图上，增加图片
//可以增加多张图片，叠加。每张图片有自己的$config
_addImg($config,$candle);

//输出 处理完的图像资源，到文件
if($suffix=="jpg"){
	Imagejpeg($candle,$filePathNew,100);
}elseif($suffix=="png"){
	Imagepng($candle,$filePathNew);
}elseif($suffix=="gif"){
	Imagegif($candle,$filePathNew);
}

header("Content-type:image/".$suffix);
//显示图像
if($suffix=="jpg"){
	Imagejpeg($candle);
}elseif($suffix=="png"){
	Imagepng($candle);
}elseif($suffix=="gif"){
	Imagegif($candle);
}





//创建画布
function _createCandle($w,$h) {
	//新建一个真彩色图像。返回资源对象
	$c=imagecreatetruecolor($w, $h);

	//设定图像的混色模式
	imagealphablending($c, true);

	//设置透明通道
	imagesavealpha($c, true);

	//设置透明色
	$trans_colour = imagecolorallocatealpha($c, 0, 0, 0, 127);

	//用透明色，填充
	imagefill($c, 0, 0, $trans_colour);

	Return $c;
}


//叠加图层
/*
$config['w'] //原宽
$config['h'] //原高
$config['nw'] //新宽
$config['nh'] //新高
$config['source'] //图像资源。文件，需要读取
$config['mouseAngle'] //旋转图像的度数
$config['isOverTurnH'] //是否水平翻转
$config['l'] //新图片，在背景图片的什么位置
$config['t'] //新图片，在背景图片的什么位置

$candle //背景图层
*/
function _addImg(&$config,&$candle) {

	//如果原/新宽高 不同，则重新创建
	if($config['w']!=$config['nw'] || $config['h']!=$config['nh']){
		//临时图层
		$candleTmp=_createCandle($config['nw'], $config['nh']);

		// 重采样拷贝部分图像并调整大小
		////目标图像，源图像 / 目标x，目标y/ 源x，源y /目标宽度，目标高度/ 源宽度，源高度
		ImageCopyResampled(
						$candleTmp,
						$config['source'],
						0,
						0,
						0,
						0,
						$config['nw'],
						$config['nh'],
						$config['w'],
						$config['h']
						);
		$config['source']=$candleTmp;
	}


	_rotateImg($config);//旋转图层

	_turnH($config);//水平翻转图层

	// 重采样拷贝部分图像并调整大小
	ImageCopyResampled(
					$candle,
					$config['source'],
					$config['l'],
					$config['t'],
					0,
					0,
					$config['nw'],
					$config['nh'],
					$config['nw'],
					$config['nh']
					);
}


//旋转图层
function _rotateImg(&$config) {
	
	if(!empty($config['mouseAngle'])){

		if($config['isOverTurnH']){//如果有水平翻转
			$hx=-1;
		}else{
			$hx=1;
		}

		//旋转图像
			//旋转参数
		$rotateSign=-1;
		$config['source'] = imagerotate(
					$config['source'],
					$hx*$rotateSign*$config['mouseAngle'],

					//设置透明色
					imagecolorallocatealpha(
											$config['source'], 
											0, 
											0, 
											0, 
											127
											)
		 );

		//重新获得图像宽高
		// 取得图像宽度
		 $config['nw']=imagesx($config['source']);
		 // 取得图像高度
		 $config['nh']=imagesy($config['source']);
	}
}


//水平反转
function _turnH(&$config){ 
	
	if($config['isOverTurnH']){

		//临时图层
		$candleTmp=_createCandle($config['nw'], $config['nh']);

		// 重采样拷贝部分图像并调整大小
		ImageCopyResampled(
							$candleTmp,
							$config['source'],
							0,
							0,
							$config['nw']-1,
							0,
							$config['nw'],
							$config['nh'],
							-1*$config['nw'],
							$config['nh']
							);
		$config['source']=$candleTmp;
	}
} 
?>

</textarea>

<div class="homework">
	作业：
	1.将原来的jquery表单验证中的验证码完成。并能点击切换。并能ajax验证
	2.
		1)写一个文件上传的form，能上传图片。上传结束后，可以产生缩略图：333*444尺寸
		2)该缩略图，右上角需要有 文字水印：互联网+
		3)该缩略图，左下角需要有 图片水印(必须是png透明图片，请自己网上找)
		4)最终该缩略图，必须是一张实际的文件图片
	<span class="answer">答案</span>：略
</div>


PHP的GD库函数大全：仅作了解
<textarea>
GetImageSize(string filename, array [imageinfo]); 取得图片的大小[即长与宽]
int ImageArc(int im, int cx, int cy, int w, int h, int s, int e, int col); 	画弧线
int ImageChar(int im, int font, int x, int y, string c, int col); 写出横向字符
int ImageCharup(int im, int font, int x, int y, string c, int col);写出竖式字符
int ImageColorTransparent(int im, int [col]); 	指定透明背景色
int ImageCopyResized(int dst_im, int src_im, int dstX, int dstY, int srcX, int srcY, int dstW, int dstH, int srcW, int srcH); 	复制新图并调整大小
int ImageCreate(int x_size, int y_size); 	建立新图
int ImageDashedLine(int im, int x1, int y1, int x2, int y2, int col); 	绘虚线
int ImageDestroy(int im); 	结束图形
int ImageFill(int im, int x, int y, int col); 	图形着色
int ImageFilledPolygon(int im, array points, int num_points, int col);多边形区域着色
int ImageFilledRectangle(int im, int x1, int y1, int x2, int y2, int col); 	矩形区域着色
int ImageFillToBorder(int im, int x, int y, int border, int col);指定颜色区域内着色
int ImageFontHeight(int font); 	取得字型的高度
int ImageFontWidth(int font); 	取得字型的宽度
int ImageInterlace(int im, int [interlace]); 	使用交错式显示与否
int ImageLine(int im, int x1, int y1, int x2, int y2, int col); 绘实线
int ImageLoadFont(string file); 	载入点阵字型
int ImagePolygon(int im, array points, int num_points, int col); 绘多边形
int ImageRectangle(int im, int x1, int y1, int x2, int y2, int col); 绘矩形
int ImageSetPixel(int im, int x, int y, int col); 	绘点
int ImageString(int im, int font, int x, int y, string s, int col); 	绘横式字符串
int ImageStringUp(int im, int font, int x, int y, string s, int col); 	绘直式字符串
int ImageSX(int im); 	取得图片的宽度
int ImageSY(int im); 	取得图片的高度
array ImageTTFBBox(int size, int angle, string fontfile, string text); 	计算 TTF 文字所占区域
array ImageTTFText(int im, int size, int angle, int x, int y, int col, string fontfile, string text); 	写 TTF 文字到图中
int ImageColorAt(int im, int x, int y); 	取得图中指定点颜色的索引值
int ImageColorClosest(int im, int red, int green, int blue); 计算色表中与指定颜色最接近者
int ImageColorExact(int im, int red, int green, int blue);计算色表上指定颜色索引值
int ImageColorResolve(int im, int red, int green, int blue); 计算色表上指定或最接近颜色的索引值
boolean ImageColorSet(int im, int index, int red, int green, int blue); 	设定色表上指定索引的颜色
array ImageColorsForIndex(int im, int index); 	取得色表上指定索引的颜色
int ImageColorsTotal(int im); 	计算图的颜色数
int ImagePSLoadFont(string filename); 	载入 PostScript 字型
void ImagePSFreeFont(int fontindex); 	卸下 PostScript 字型
int ImagePSEncodeFont(string encodingfile); 	PostScript 字型转成向量字
array ImagePSText(int image, string text, int font, int size, int foreground, int background, int x, int y, int space, int tightness, float angle, int antialias_steps); 	写 PostScript 文字到图中
array ImagePSBBox(string text, int font, int size, int space, int width, float angle); 	计算 PostScript 文字所占区域
int ImageCreateFromPng(string filename); 	取出 PNG 图型
int ImagePng(int im, string [filename]); 	建立 PNG 图型
int ImageCreateFromGif(string filename); 	取出 GIF 图型
int ImageGif(int im, string [filename]); 	建立 GIF 图型
</textarea>
</pre>
	</li>

	</ul>
</div>

<br>
<div id="bio">
	<li>
		<h1>
			<a href="###" style="cursor:point;text-decoration:none;" class="hs_1">第十二部分 正则表达式</a>
		</h1>
	</li>

	<ul>
		<li>
	<pre>
正则表达式是匹配字符串用的，
可按照自定义规则，查找某个字符串是否符合规则，或按规则替换一些字符
可以用来验证客户的输入数据。

我们使用正则主要用于分割、匹配、查找、替换的操作。
例如输入的是否为邮箱，是否输入了不该输入的内容等等。

<b>正则应用</b>
下面是from表单提交过来的用户名验证：
<font color=red>(注册用户名)20位以内的 英文小写或者数字，字母开头</font>
<textarea>
<?php
  header('Content-Type: text/html; charset=UTF-8');
  $email = $_GET['username'];
  $preg = '/^[a-z][a-z0-9]{0,19}/'; 
  $ok = preg_match_all($preg,$email);
  var_dump($ok);
  if($ok != 0){
    echo '用户名合法';
  }else {
    echo '用户名不合法';
  }
?>
</textarea>


正则表达式是由以下几个部分组成
1）定界符：定义正则的边界
2）原子：是正则不可分割的最小组成单位
3）元字符：不能单独使用，是配合原子使用的，用来拓展原子的功能、修饰和限定原子
4）模式修正符：对整个正则的修正

下面我我们来按照顺序依次给大家介绍这四种组成部分
<b>定界符</b>：
$preg = '//'; 

其中的两个//就是正则的定界符，所有的正则语法写在//之间（模式修正符在//之外），除了使用//之外，还可以使用!!、||、@@等。除字母、数字和斜线“\”，其他任何字符都能做定界符。这里就不一一演示了，值得一提的是正则通常都用//表示，业内普遍使用//，为了代码可读性和方便别人维护，默认使用//来做定界符，我们作为初学者，就遵循这个规范来写吧。

<b>原子</b>：
原子是最小的组成单元。
$preg = '/a/'; 

其中a就是原子，这个正则的意思就是字母a。
其中有一些原子是通用的。例如你们可以想到表示所有数字的，表示所有字母的，下面介绍一些常用的通配符：
\d  表示所有数字，相当于[0-9]
\D  表示非数字，相当于[^0-9]
\w  表示字，相当于[a-zA-Z0-9_]
\W  表示非字，相当于[^a-zA-Z0-9_]
\s  表示打印字符，\n \t  \
\S  表示非打印字符，除了空格回车垂直制表符等

<b>元字符</b>：
*       前面的原子匹配匹配任意次
+       前面的原子匹配一次或多次
?       前面的原子匹配0次或者1次
|       前面的原子匹配两个或者多个分支（或的关系，两边出现一次即可匹配，优先级最低）
{n}     前面的原子匹配n次
{n,}    前面的原子匹配至少n次
{n,m}   前面的原子匹配n到m次
^或\A   目标字符串必须以什么什么开始（在多行中表示每一行第一个，在[]中表示非，例如[^a]就是除了a）
$或\Z   目标字符串必须以什么什么结尾（在多行中表示每行最后一个）
\b      单词边界
\B      除了单词以外的部分
()      1.改变优先级别2.将小原子变成大原子(add)*就是add这个单词任意次，不是d字符任意次3.子模式比如(http|https),在()中加?:取消子模式即(?:)4.反向引用
^与$    要在两端，表示以什么什么开始和以什么什么结尾，例如'/^a$/',就是必须a开始，a结尾的字符串


<b>模式修正符</b>：
1.写在定界符右边
2.可以组合写，也可以单独写（就是可以写一个或者多个）
常用的有
i  不区分大小写
m  视为多行（^$每一行）
s  可以匹配换行
x  忽略空白
v  取消贪婪模式，或者使用'(.*?)'取消，使用'(.*?)'就不能使用u


<b style="color:red">常用的正则 （一个个写出来，或者讲出规则。同时并测试）</b>
<textarea>
<?php

$str=isset($_POST['username'])?$_POST['username']:"";


//(注册用户名)20位以内的 英文小写或者数字，字母开头
$rule="/^[a-z][a-z0-9]{0,19}/";

//(注册用户名)20位以内的 英文小写或者数字，字母开头，最少4位
$rule="/^[a-z][a-z0-9]{3,19}/";

//(注册用户名)20位以内的 带下划线的英文名
$rule="/^[a-z_][a-z0-9_]{0,19}/";

//(会计算账) 只要是数字，包括正负整数/浮点
$rule="/^[0-9]{1,}[\.|0-9]{0,1}[0-9]{1,}$/";
$rule_1="/^[+-]?[0-9]{1,}$/";
$rule_2="/^[+-]?[0-9]{1,}[\.|0-9]{0,1}[0-9]{1,}$/";

//(价格/考试分数) 正数(包括小数和整数)
$rule_1="/^[+]?[0-9]{1,}$/";
$rule_2="/^[+]?[0-9]{1,}[\.|0-9]{0,1}[0-9]{1,}$/";

//(购买数量)自然数
$rule="/^[0-9]+$/";

//邮箱 888-+.88@sina.com  www@www.www
$rule="/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/";

//邮编
$rule="/^[1-9]\d{5}$/";

//中文
//$rule="/^[".chr(0xa1)."-".chr(0xff)."]+$/";//gb2312中文
//$rule="/^[\x{4e00}-\x{9fa5}]+$/u";//utf-8 中文
$rule="/^[\x80-\xff_a-zA-Z0-9]{3,15}/";//utf-8 包括中文

//纯英文
$rule="/^[a-z]+$/i";

//手机
$rule="/^((\(\d{3}\))|(\d{3}\-)|(0))?1[34578]{1}\d{9}$/";

//固定电话
$rule="/^(\d{3}-)(\d{8})$|^(\d{4}-)(\d{7})$|^(\d{7})$|^(\d{8})$/";

//身份证
//(18位)
//3 40103 2006 07 07 333 X
$rule="/^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}[\dXY]{1}$/";

//ip 127.0.0.1  202.102.192.68
$rule="/^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/";

if(preg_match($rule,$str)==1){
	echo 1;
}else{
	echo -1;
}

/* js正则验证
e.value =e.value.replace(/[^\u4e00-\u9fa5]/g,'')
replace(/[^a-zA-Z\d]/g,'')
replace(/[^\d]/g,'')
e.value = e.value.replace(/[^\d\.]/g, ""); 
e.value = e.value.replace(/^(\d+)\.(\d\d).*$/, '$1.$2');
style="ime-mode:disabled"
*/
?>

<?php
/*
	正则验证
	$str：验证的字符串
	$type：类型
	$l：长度：-1/数组/数字： 不限制长度/长度范围/限制最大
*/
function check($str,$type="",$l=""){
	static $rules=array(
		//(注册用户名)  英文小写和数字 
		"en"=>"/^[a-z][a-z0-9]{1,}$/",

		//(注册用户名) 不带下划线的英文小写
		'en_'=>"/^[a-z_][a-z0-9_]{1,}/",
		
		//（密码）英文小写和数字和_-@
		"en_-@"=>"/^[a-z0-9_\-\!@]{1,}$/",

		//纯英文小写
		'e'=>"/^[a-z]+$/",

		//只能是英文数字下划线和中文
		"enc"=>"/^(\w|[\x80-\xff])*$/",


		//数字
		'num1'=>"/^[0-9]{1,}[\.|0-9]{0,1}[0-9]{1,}$/",

		//整数
		'num2'=>"/^[0-9]+$/",

		//邮箱
		"email"=>"/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/",

		//手机
		'phone'=>"/^((\(\d{3}\))|(\d{3}\-)|(0))?1[34578]{1}\d{9}$/",

		//固定电话
		'tel'=>"/^(\d{3}-)(\d{8})$|^(\d{4}-)(\d{7})$|^(\d{7})$|^(\d{8})$/",

		//邮政编码
		'zip'=>"/^[1-9]\d{5}$/",

		//身份证
		//(18位)
		//3 40103 2006 07 07 333 X
		'idcard'=>"/^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}[\dXY]{1}$/",

		//ip 127.0.0.1  202.102.192.68
		'ip'=>"/^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/"
	);


	if(empty($type)){//不检查类型
		if(empty($l)){//如果不验证长度
			return 1;

		}else if(is_array($l)){
			if(mb_strlen($str,'utf-8') < $l[0] || mb_strlen($str,'utf-8') > $l[1]){
				return -1;
			}
		}else {
			if(mb_strlen($str,'utf-8')> $l){
				return -2;
			}
		}
		return 1;

	}else if(preg_match($rules[$type],$str)!=1){//如果类型验证没有通过
		return -3;

	}else{//如果类型验证通过
		if(empty($l)){//如果不验证长度
				return 1;

		}else if(is_array($l)){
			if(mb_strlen($str,'utf-8') < $l[0] || mb_strlen($str,'utf-8') > $l[1]){
				return -1;
			}
		}else {
			if(mb_strlen($str,'utf-8')> $l){
				return -2;
			}
		}
		
		return 1;
	}
}
?>

<script>
/*
	str：验证的字符串
	type：类型
	l：长度：-1/数组/数字： 不限制长度/长度范围/限制最大
*/
function check(str,type,l){

	var ruleList={
		//(注册用户名)  英文小写和数字 
		"en":/^[a-z][a-z0-9]{1,}$/,

		//(注册用户名) 不带下划线的英文小写
		'en_':/^[a-z_][a-z0-9_]{1,}/,
		
		//（密码）英文小写和数字和_-@
		"en_-@":/^[a-z0-9_\-\!@]{1,}$/,

		//纯英文
		'e':/^[a-z]+$/i,

		//只能是英文数字下划线和中文
		"enc":/^(\w|[\u4E00-\u9FA5])*$/,


		//数字
		'num1':/^[0-9]{1,}[\.|0-9]{0,1}[0-9]{1,}$/,

		//整数
		'num2':/^[0-9]+$/,

		//邮箱
		"email":/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/,

		//手机
		'phone':/^((\(\d{3}\))|(\d{3}\-)|(0))?1[34578]{1}\d{9}$/,

		//固定电话
		'tel':/^(\d{3}-)(\d{8})$|^(\d{4}-)(\d{7})$|^(\d{7})$|^(\d{8})$/,

		//邮政编码
		'zip':/^[1-9]\d{5}$/,

		//身份证
		//(18位)
		//3 40103 2006 07 07 333 X
		'idcard':/^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}[\dXY]{1}$/,

		//ip 127.0.0.1  202.102.192.68
		'ip':/^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/
	}

	if(!type){//如果没有类型需要验证
		if(!l){//如果不验证长度
			return 1;

		}else if(typeof(l)=='object'){
			if(str.length < l[0] || str.length> l[1]){
				return -1;
			}
		}else {
			if(str.length> l){
				return -2;
			}
		}
		return 1;
	}else if(ruleList[type].test(str)==false){//如果类型验证没有通过

		return -3;

	}else{//如果类型验证通过
		if(!l){//如果不验证长度
			return 1;

		}else if(typeof(l)=='object'){
			if(str.length < l[0] || str.length> l[1]){
				return -1;
			}
		}else {
			if(str.length> l){
				return -2;
			}
		}
		return 1;
	}
}
</script>
</textarea>

<font color=red>注册案例</font>
！！！使用了中文注册码，需要字体

//注册页面
reg.html

<textarea>
<html>
<head>
<meta charset="utf-8">
<style>
.info{
	background:blue;
	color:#ffffff;
}

.img_code{
	cursor:pointer 
}

</style>

<script src="./jquery-1.7.js"></script>
<script>
$(document).ready(
	function (){
		$("#username").bind(
			"keyup",
			function (){
				this.value=this.value.replace(/[^a-z\d]/g,'')
			}
		)

		//替换
		$("#phone").bind(
			"keyup",
			function (){
				this.value=this.value.replace(/[^\d]/g,'')
			}
		)

		//替换
		$("#price").bind(
			"keyup",
			function (){
				this.value = this.value.replace(/[^\d\.]/g, ""); 

this.value =this.value.replace(
								/^(\d+)\.(\d\d).$/, '$1.$2');
			}
		)

			
	}
)


function page_check(){
	//检查之前，把提示信息，全部删除
	$(".info").html("");

	//用户名
	var pattern = /^[a-z][a-z0-9]{7,19}$/i;

	//密码
	var pattern2=/^[a-z0-9_\-\!@]{8,20}$/i;

	//邮箱
	var pattern3=/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/;

	//手机
	var pattern4=/^((\(\d{3}\))|(\d{3}\-)|(0))?1[34578]{1}\d{9}$/;

	//验证码
	var pattern5= /[\u4E00-\u9FA5\uF900-\uFA2D]/;
	

	
	var v=false;
	if(pattern.test($("#username").val())==false){
		$("#username").next().html("用户名不符合规则！");

		//$("#username").next().css({"background":"yellow","color":"red"})

		return false;

	}else if(pattern2.test($("#password").val())==false){
		
		$("#password").next().html("密码不符合规则！");

		//$("#password").next().addClass("info");

		return false;
	}else if($("#password").val()!=$("#rpassword").val()){
		
		$("#rpassword").next().html("重复密码和密码不一致");
		return false;

	}else if(pattern3.test($("#email").val())==false){
		
		$("#email").next().html("邮箱不符合规则");
		return false;
	}else if(pattern4.test($("#phone").val())==false){
		
		$("#phone").next().html("手机号不符合规则");
		return false;

	}else if(pattern5.test($("#code").val())==false || $("#code").val().length!=4){
		
		
		$("#code").next().html("验证码不符合规则");
		return false;
	}else{
		$.ajax(
				{
					url: "./checkImgCode.php",
					type: "post",
					data: {
						'imgCode':$("#code").val(),
						'test':123
					},

					async: false,
					dataType: "json",
					success: function(data){
					
						if(data['code']<0){
							$("#code").next().html("验证码错误");

							page_changeImgCode();

						}else{
							v=true;
						}
					}
				}
				
				);
		}
		
		return v;
	}


function page_changeImgCode(){
	$(".img_code").attr("src",'./imgCode.php?t='+Math.random())
}

</script>
</head>

<body>
<form action="./actionReg.php" method="post" onsubmit="return page_check()">

用户名：<input id="username" name="username">
<span class="info"></span><br>

密码：<input id="password" name="password">
<span class="info"></span><br>

重复密码：<input id="rpassword" name="rpassword">
<span class="info"></span><br>

邮箱：<input id="email" name="email">
<span class="info"></span><br>

手机：<input id="phone" name="phone">
<span class="info"></span><br>

验证码：<input id="code" name="code">
<span class="info"></span><br>
<img class="img_code" src="./imgCode.php" onclick="page_changeImgCode()">
<a href="###" onclick="page_changeImgCode()">看不清？</a>
<br>

	<input type="submit" ><br>
</form>


<br>
<br>
<br>
商品单价：
<input id="price">
</body>
</html>

</textarea>

//验证码
imgCode.php

<textarea>
<?php		
session_start();//生成验证码图片

Header("Content-type:image/PNG");

//定义宽高
$width=180;
$height=50;

//定义生成数量
$num=4;

//每个文字宽度
$font_width=floor($width/($num+1));//多加1个文字，为了 left和right能有空，好看

//定义字体！！！需要准备好中文字体文件
$font=dirname(__FILE__)."/china.ttf";
//字体大小
$fontSize=25;


//字符串范围
$strList="定义很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字定义很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字定义0123455很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字abcdeeddaddaf定义很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字定义很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字定义很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字定义很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字定义很多不重复的中文字或者从网上找一些都没有问题的或者加上英文和数字";



//画一张指定宽高的图片
$im = imagecreate($width, $height);

//定义背景颜色	//把背景颜色填充到刚刚画出来的图片中
$back = imagecolorallocate($im, 255, 255, 255);

$vcodes ="";

//生成每个文字
for($i = 0; $i < $num; $i++){	
	
	//定义颜色
	$fontColor = imagecolorallocate($im, rand(0, 255), rand(0, 255), rand(0, 255));

	//随机获得文字
	$n=rand(0, mb_strlen($strList,'utf-8'));
	$authnum = mb_substr($strList,$n,1,'utf-8');

	//角度范围
	$fontAngle=rand(-20,20);

	$boxSize=imagettfbbox( $fontSize , $fontAngle, $font ,$authnum );//文字整体大小

	//$fontX=abs($boxSize[0]-$boxSize[2]);//文字宽度
	$fontY=abs($boxSize[1]-$boxSize[7]);//文字高度

	$x=$font_width*$i+floor($font_width/2);//左下角x坐标。增加半个文字位置
	
	$y= ($height - $fontY)/2 +$fontY;//左下角y坐标


	//写字
	imagettftext($im, $fontSize, $fontAngle, $x, $y, $fontColor, $font, $authnum);

	$vcodes .= $authnum;//给session用
}


//干扰素密度
$pixelLength=40/3000*($width*$height);

for($i=0;$i<$pixelLength;$i++) { 
	//定义干扰象素颜色
	$randcolor = imagecolorallocate($im, rand(0, 255),rand(0,255), rand(0, 255));

	// 画像素点函数
	imagesetpixel($im, rand(0,$width), rand(0,$height),$randcolor); 
}

imagepng($im);		
imagedestroy($im);

//写到session
$_SESSION['VCODE'] = md5($vcodes);

?>


</textarea>

//ajax检查验证码
checkImgCode.php
<textarea>
<?php
session_start();
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//不屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国
//set_time_limit(0);//设定一个程式所允许执行的秒数,如果到达限制的时间,程式将会传回错误

$imgCode=!empty($_POST['imgCode'])?$_POST['imgCode']:"";

$d=array(
		"code"=>-1,
		"info"=>"错误",
);
if( md5($imgCode)==$_SESSION['VCODE']){
	$d=array(
		"code"=>1,
		"info"=>"正确",
		'xyz'=>123
	);
	echo json_encode($d);
}else{
	echo json_encode($d);
}
?>
</textarea>

可能会用到的函数
1. preg_filter(正则,替换成什么,需要替换的字符串) — 执行一个正则表达式搜索和替换
2. preg_grep(正则,输入的数组) — 返回匹配模式的数组条目
3. preg_last_error(void) — 返回最后一个PCRE正则执行产生的错误代码
4. preg_match_all(正则,需要查找的字符串,查找到的结果) — 执行一个全局正则表达式匹配
5. preg_match(正则,需要查找的字符串,查找到的结果) — 执行一个正则表达式匹配
6. preg_quote(str) — 转义正则表达式字符
7. preg_replace_callback(正则,回调函数,需要搜索的字符串) — 执行一个正则表达式搜索并且使用一个回调进行替换
8. preg_replace(正则,替换成什么,需要替换的字符串) — 执行一个正则表达式的搜索和替换
9. preg_split(正则,需要分割的字符串) — 通过一个正则表达式分隔字符串

</pre>
		</li>
	</ul>
</div>

<br>
<div id="bio">
	<li>
		<h1>
			<a href="###" style="cursor:point;text-decoration:none;" class="hs_1">第十三部分 mysql数据库</a>
		</h1>
	</li>

	<ul>
		<li>
			<b class="hs_2">1.什么是数据库</b>

<pre class="hs_2_son">
按照数据结构来组织、存储和管理数据的仓库
也就是，
1)内存里面运行的变量值，如何在断电后不丢失？下次来电时又重还原？
那就需要将关键性数据，及时地保存到硬盘上
2)保存到文本里面可以吗？
可以的。曾经有一种挺有名的论坛，数据全部保存在文本里
3)若保存在文本里面，你准备用1个文本，还是几个文本？怎样组织文本里面的内容，以便下次更好取出，或者修改呢？
那么，数据库就是：按照某种数据结构来组织、存储和管理数据。所以我们直接使用数据库
4)数据库中的内容，也是保存在硬盘上的
</pre>

		</li>
		<li>
			<b class="hs_2">2.数据库分类</b>
<pre class="hs_2_son">
1)按照存储模式看：关系型数据库/面向对象型数据库，等
2)按照商业名称看：mysql/mssql/oracle/sybase，等
我们现在要学的是：关系型数据库：mysql
</pre>
		</li>
		<li>
			<b class="hs_2">3.mysql数据库简述</b>
<pre class="hs_2_son">
1)数据保存位置：通常在mysql目录下的data目录下。每个文件夹都是一个独立数据库（打开目录给学生看）
2)mysql数据库可以说是一种数据库的名字，也可以叫mysql数据库服务。
这个数据库服务在某台服务器安装后，可以保存多个独立数据库
这里的多个独立数据库指的是：
	(1)一台服务器上，可以有多个网站，或者多个项目
	(2)每个网站，或者每个项目，它的数据都单独保存某处，形象上说明：就是上面说的 mysql/data/下的每个文件夹
3)在php程序和mysql数据库存放关系
	(1)一台服务器上，可以同时存在php程序和mysql数据库
	(2)php程序和mysql数据库，也可以单独放在两台以上服务器上。这时php程序所在服务器叫做web服务器，mysql所在服务器叫做数据库服务器。也就是php程序可以远程连接另外一台服务器上的mysql数据库，只要知道用户名和密码
4)mysql数据库服务，使用的端口号，通常是3306。也可以在mysql配置文件中修改(cmd netstat -aon/wmic process)
5)mysql配置文件：win上是my.ini / linux上是 my.cnf。win上位置是 mysql/my.ini
6)管理工具：通常我们用phpMyAdmin这个web软件管理mysql数据库，它本身就是用php编写的。也有一些其他的cs软件可以管理如：mysqlfront等。特别的，有在命令行进行一些mysql系统管理的操作。任何实际项目中不存在用命令行管理数据库的事情，任何类型的数据库在项目中都是使用数据库管理软件管理的
7)管理内容：用phpMyAdmin演示以下操作
	(1)登陆：root是数据库管理员账号，可管理所有数据库。
	(2)设置新账号：可以为某个账号，设置只能管理某些数据库，或者只能查看，不能删除或修改等
	(3)权限：可以为某个账号，设置只能管理某些数据库，或者只能查看，不能删除或修改等
	(4)建库：编码，通常我们使用utf-8_general_ci
</pre>
		</li>

<li>
			<b class="hs_2">4.mysql建库和建表</b>
<pre class="hs_2_son">
1)mysql中表名是区分大小写的，字段名不区分，一般都使用英文。
也可以用中文的，但那是为了好玩。
可以用拼音字母，没有一个真实项目使用拼音的。
库名/表名/字段名，起的英文名可以是没有业务意义的，但真实项目都是正确的单词。
故：<font color=red>真实项目中，全部使用小写，驼峰式改成下横杠，全部用有业务意义的英文单词</font>。
我们以后完全参照真实项目使用写
2)建立数据库：my_item，使用编码utf-8_general_ci
	建立成功后，会发现有一条sql语句出现：
	CREATE DATABASE `my_item` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
	这是phpMyAdmin较有用的特性。所有操作都会sql语句提示。sql语句之后再说到

3)建立数据表：user：手工建立给学生看
	并设置8个字段：
	id/user_name/password/nice_name/sex/groups/reg_time/last_login_time：
	用户id：整形/无正负/主键
	用户名：不定长字符串，20位。唯一
	密码：定长字符串32位
	用户昵称：不定长字符串，20位
	性别：定长字符串，1位
	所在组：整形/无正负/默认为1 / 做索引
	注册时间：整形/无正负/ 
	最后登陆时间：日期时间类型。这里是为了测试，真正项目中，应该只统一用1种时间：时间戳或日期时间

	然后使用phpMyAdmin插入 2条 用户数据。
	其中：
	密码字段使用phpMyAdmin上的mysql的md5函数
	注册时间，先用php计算好时间戳。或使用mysql的unix_timestamp函数

4)如何理解上述操作
	(1)建立数据库my_item的目的：是要将某项目数据保存在一个独立的空间。好像开辟了一个房间出来
	(2)建立数据表user的目的：
		从业务上来说，user表通常是每个项目的数据库中必备的。
			它保存了一些用户的信息，代表了只有这些用户有权限使用my_item库中(项目中)的其他内容。当前my_item库中只有user表，以后还会有很多
			每个项目中用户表user可能名字不一定就是user，可能会叫memeber。甚至还会再多分出一张管理员的用户表，例如：admin。里面只存放管理员用户

		从数据表设计的基本思想来说：通常，我们应当为项目中同一类的东西，至少设计1张表
			如：若经常在新浪看新闻，应能理解，在新浪数据库中，只少有一张新闻表，保存新闻这一类数据
			如：若经常在淘宝上买东西，应能理解，在淘宝数据库中，只少有一张商品表，保存商品这一类数据
		故当前：我们为项目中涉及的用户，这一类东西，建立了一张表：user

	(3)那么，一个项目中除了建立用户表，还要建立哪些数据表呢
		从业务上来说，涉及到我们对项目的分析。分析总的分5部分
			第1部分：要分析出这个项目，它存在于世界上的，核心价值是什么（除了为了赚钱的商业价值）。
				例如客户要求做一个：个人博客。
				个人博客，存在于世界上的核心价值在于：通过展示自己、寻找同好，能建立一定的交际圈

			第2部分：分析出要达到这个价值，是通过哪些人，去做哪些事才完成的（业务流程。业务用例模型图）
				个人博客的核心价值是通过以下事情完成的
				博客用户：把自己想说的事情，放到自己的个人博客中。
				博客用户：想让别人看到自己的博客
				博客用户：想和其他博客用户相互交流，包括：相互关注，相互收藏，相互评论，加好友圈

			第3部分：分析出每种业务流程中，由哪些步骤组成的(流程活动。业务流程活动图)
				把自己想说的事情，放到自己的个人博客中(流程)：用户填写发布内容，并发布(流程活动)
				加好友圈：加好友请求(流程活动)/对方审核(流程活动)

			第4部分：根据业务流程和其业务活动，分析出多个系统活动(系统用例)
				加好友圈的加好友请求：系统审核登陆/博客用户填写好友请求/系统查询是否是好友，是否黑名单/对方审核
			
			第5部分：抽取系统活动涉及到的人、事、物
				系统活动的启动者(人/系统)，参与者(人/系统)：好友发起者，好友确认者，系统
				系统活动开始需要什么东西(物)，活动结束会生成什么东西(物)：发起者基本信息，发起者和审核者原来的关系，发起者请求的内容/发起者和审核者产生关联关系
				系统活动本身发生的事情：这个加好友的动作本身

			以上5部分，通常都是通过反复询问客户，通过多次迭代得到的。复杂的分析和设计需要几个月时间
			当前，没有询问客户就能叙述出上述内容，是因为该项目已经开发过。
			在设计师心中已经存在这种业务模型和系统模型，可以复用。可见最高层的复用在于业务模型，而非代码

		从数据表设计来说，分2部分
			第1部分：我们将上述需要长期保存(持久化)的人、事、物，分分类，准备设计数据表
			第2部分：设计的时候，要考虑尽量减少数据实际保存时的冗余
				例如：发起者和审核者产生关联关系，是记录两者的姓名，还是记录两者各自的编号
			这通常我们通过数据库设计的三大范式来指导和拷问数据表设计（下面章节说到）

5)什么是数据表的字段
当前我们要创建用户表的业务原因，上述已经说的很清楚了。
那么，用户表创建后，里面应该存储用户的什么信息呢
这是根据每个项目的业务要求来确定的
	用户表里面要不要保存每个用户的身份证号码？DNA信息？
	如果你的业务需要，那就要保存，否则不同项目中的用户表，里面存储的东西，可以都不太一样，但它们都是用户表

当前根据个人博客项目的实际业务，暂时分析认为，用户表里面需要保存8样东西
id：用户id。本项目中的用户编号，好像身份证号一样，来说明每个人的区别。int 无正负
user_name：用户登录名称。20位varchar
password：登陆时用的密码。32位char
nice_name：用户的昵称。20位varchar
sex：1/2:男/女。1位 char
groups：所在组。例如管理员和普通用户。整形，无正负
reg_time：注册的时间。整形，无正负
last_login_time：最后登陆的时间。datetime

这8样东西，在数据表创建时，就要确定好，并为它们起好名字。
它们就叫做：数据表里面的字段

我们想一下，若因为业务需要，建立博客项目中的博客内容数据表，应该有哪些字段？
博客内容数据表，通常应该保存哪些东西？
	发布者/发布的标题/发布的内容/发布的时间
	
	请手工建立给学生看
	blog_content表
	
	id：整形/无正负/主键。每条博客内容的标识/身份证号/id
	title：100个不定长字符。每条博客的标题
	contents：text类型。每条博客的内容
	add_user_id：整形/无正负/做索引。发布者是谁：这里我们是保存发布者的id（编号），而不用用户的登陆名称，为了减少数据库存储的冗余
	add_time：日期时间类型。发布时间
	
6)字段类型
数据表创建时，除了要想好有哪些字段，和名称，还要想好字段的类型
	不同的字段的类型，数据库会用不同的方式存储和查询，速度是不一样的
	所以定义好正确的类型，会让我们的项目变得快

常用字段：
		int: 整形
		float：浮点
		varchar：不定长有限字符串
		char:定长有限字符串
		text：不定长无限字符串
		datetime:日期和时间

实际上什么时候用什么类型呢
	(1)数字：要保存的内容是数字，包括整数和小数
		整数例如：
			用户id
			博客id
			商品id
			省/市/区编号
			订单编号
			用户评价几颗星

			<b>int</b>：常用：可不指定长度。-2147483648/2147483647(无符号4294967295) 自动补0
			TINYINT：业务上能确定，小于3位时使用。-128 /127
			BIGINT：业务上能确定，大于9位时使用。
			等

		小数例如：
			成绩分数
			商品单价
			订单支付价格

			<b>decimal(65, 30)</b>：参数（一共多少位，小数点后几位）。常用
			float：精度没有上面高。具体可查mysql手册
			DOUBLE：精度没有上面高

	(2)时间：
		时间例如
			注册时间
			退出时间
			发布时间
			订单产生时间
			支付时间
					
			<b>Int</b>：常用。整数，记录时间戳类型
			<b>DATETIME</b>：常用。日期时间格式：2015-05-05 05:05:05
			YEAR：年
			DATE：月日

	(3)字符串
		字符串例如
			姓名
			新闻标题/内容
			商品名称/介绍
			学校名字
			公司名称
			状态：1/2/3。可以用整形或者char

			<b>VARCHAR</b>：可变有限长度，255位。不能换行
			CHAR</b>：固定有限长度。不能换行
			<b>Text</b>:没有长度限制/可换行

	(4)二进制（不做要求）
			TinyBlob 255
			Blob 65K 
			MediumBlob 16M (使用addslashes/ base64_encode)
			LongBlob 4G 
			BINARY/VARBINARY

	(5)其他（不做要求）
		ENUM/SET：单选/多选


7)设置字段为主键，或者唯一
通常，每张数据表，都有一个字段叫做：主键
	(1)主键字段的值，所有条记录，都不会有重复
	(2)这就可以达成，通过这个主键字段的值，就可以找到一条记录
		否则，我们虽然将数据存储进数据表后，如何将需要的找出来呢
		这个主键的作用，就好像数组下标那样
	(3)mysql里面的主键，通常设置为自动增加。每加一条记录，系统会自动填充这个字段的值，让其自动加1，不重复
	(4)有些数据表可以没有主键
		这张表是其他表的扩展表
		这样表保存了其他2张表的关联

		这将在第7节会说到

有些时候，除了主键，还有一些字段需要设置成唯一，就是不能重复
	例如：用户表，除了有主键：用户id外，还需要设置用户登录名称：唯一

将主键设置，和唯一设置，操作给学生看
<div class="homework">
		作业：
		1.建立blog内容分类表。包括：分类id/分类名称 2个字段，并要加上数据表和字段注释（从此所有建表都要加注释）
		2.建立学校图书馆数据库 中的，图书表
		3.建立电商网站数据库 中的，商品表
		<span class="answer">答案</span>：无标准答案，根据项目需要。故学生作业需要说明为什么要这样建立的原因
</div>
</pre>
</li>

<li>
<b class="hs_2">5.如何用php程序连接数据库，并进行查询，显示列表</b>
<pre class="hs_2_son">
<textarea>
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国

// 1. 连接数据库服务器，产生句柄。用@屏蔽错误
$dbLink=@mysql_connect("127.0.0.1","root","");
if(empty($dbLink)){
	exit("连接数据库失败");
}

// 2. 在服务器上，选择数据库。
//可以不带连接句柄变量，若不带，为最新连接的数据库
$dbSelect=@mysql_select_db("my_item",$dbLink);
if(empty($dbSelect)){
	exit("数据库选择失败");
}

// 3.做一些准备工作
//设置编码。
//为了避免出现乱码，我们通常将数据库编码，php文件编码，和html的meta中的编码设置成一样
mysql_query("SET NAMES utf8",$dbLink);
//屏蔽宽字符集漏洞
mysql_query("SET character_set_client=binary",$dbLink);

// 4.写一个sql查询语句
//详细在第6节说到
//当前意思是，从用户表user中取出所有内容
$sql="select * from user ";

// 5. 进行查询，并返回查询句柄
$queryLink=mysql_query($sql,$dbLink);
if(mysql_errno($dbLink)!=0){//若存在查询错误
	 exit(mysql_errno ($dbLink).": ".mysql_error ($dbLink));
}

echo "<pre>";
// 6. 循环输出结果
while ( $row  =  mysql_fetch_array($queryLink,MYSQL_ASSOC)) {
	echo $row['id'];
	echo "<br>";
	print_r($row);
}
?>
</textarea>
<div class="homework">
		作业：
		将之前的blog内容分类表/图书表/商品表内容，都用php显示出来。注意是连接不同的数据库
		<span class="answer">答案</span>：略
</div>
</pre>
</li>


<li>
<b class="hs_2">6.基础sql语句</b>
<pre class="hs_2_son">
1)对数据库的操作，我们只能用sql语句来完成。它是对数据库操作的命令。它本身是字符串
虽然之前我们好像用phpMyAdmin操作，加入一些数据，没有涉及到sql语句，其实是phpMyAdmin这个软件自己组装了sql语句，去执行才能完成
2)sql语句，从其完成的目的看，分为创建/修改/读取/删除：create/update/read/delete：
也叫CURD操作
3)
	(1)查询
<textarea>
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国

// 1. 连接数据库服务器，产生句柄。用@屏蔽错误
$dbLink=@mysql_connect("127.0.0.1","root","");
if(empty($dbLink)){
	exit("连接数据库失败");
}

// 2. 在服务器上，选择数据库。
//可以不带连接句柄变量，若不带，为最新连接的数据库
$dbSelect=@mysql_select_db("my_item",$dbLink);
if(empty($dbSelect)){
	exit("数据库选择失败");
}

// 3.做一些准备工作
//设置编码。
//为了避免出现乱码，我们通常将数据库编码，php文件编码，和html的meta中的编码设置成一样
mysql_query("SET NAMES utf8",$dbLink);
//屏蔽宽字符集漏洞
mysql_query("SET character_set_client=binary",$dbLink);

// 4.写一个sql查询语句
/*
select 选择哪些字段，可以用逗号隔开。*号代表所有
from 从那张表查询数据
where 有什么条件
	一般常用的是
		字段 =
		字段 !=
		字段 >
		字段 >=
		字段 <
		字段 <=
		字段 between and 
		字段 in
		字段 not in
		字段 IS NULL
		字段 IS not NULL
		字段 like '%%'
	
	条件间关系一般常用用
		and
		or

order by 按哪个字段排序。asc/desc/rand()：顺序，默认/倒序/随机

//测试一下，以上变动后的效果
*/

$sql="
		select * 
		from 
			user
		where
			id=1
		order by 
			id desc
		";
	

// 5. 进行查询，并返回查询句柄
$queryLink=mysql_query($sql,$dbLink);
if(mysql_errno($dbLink)!=0){//若存在查询错误
	 exit(mysql_errno ($dbLink).": ".mysql_error ($dbLink));
}

echo "<pre>";
// 6. 循环输出结果
//说一下mysql_fetch_array函数的第二个参数
while ( $row  =  mysql_fetch_array($queryLink,MYSQL_ASSOC)) {
	echo $row['id'];
	echo "<br>";
	print_r($row);
}
?>
</textarea>
	(2)插入
<textarea>
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国


// 1. 连接数据库服务器，产生句柄。用@屏蔽错误
$dbLink=@mysql_connect("127.0.0.1","root","");
if(empty($dbLink)){
	exit("连接数据库失败");
}

// 2. 在服务器上，选择数据库。
//可以不带连接句柄变量，若不带，为最新连接的数据库
$dbSelect=@mysql_select_db("my_item",$dbLink);
if(empty($dbSelect)){
	exit("数据库选择失败");
}

// 3.做一些准备工作
//设置编码。
//为了避免出现乱码，我们通常将数据库编码，php文件编码，和html的meta中的编码设置成一样
mysql_query("SET NAMES utf8",$dbLink);
//屏蔽宽字符集漏洞
mysql_query("SET character_set_client=binary",$dbLink);

// 4.写一个插入的sql查询语句
$user_name="test";
$password=md5("456");
$sql="
	insert into 
		user
	set 
		user_name='".$user_name."',
		password='".$password."'
";

echo $sql;
echo "<br>";

// 5. 进行查询，并返回查询句柄
$queryLink=mysql_query($sql,$dbLink);
if(mysql_errno($dbLink)!=0){//若存在查询错误
	 exit(mysql_errno ($dbLink).": ".mysql_error ($dbLink));
}

echo "<pre>";
// 6. 获得最后自增号
//若数据表有自增主键，则可通过以下函数获得最后插入的记录的，自增号
$lastId=mysql_insert_id($dbLink);
echo $lastId;

</textarea>
若上述程序一点不改变，再反复执行，会不会报错？为什么？
因为用户名唯一

	(3)修改
<textarea>
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国


// 1. 连接数据库服务器，产生句柄。用@屏蔽错误
$dbLink=@mysql_connect("127.0.0.1","root","");
if(empty($dbLink)){
	exit("连接数据库失败");
}

// 2. 在服务器上，选择数据库。
//可以不带连接句柄变量，若不带，为最新连接的数据库
$dbSelect=@mysql_select_db("my_item",$dbLink);
if(empty($dbSelect)){
	exit("数据库选择失败");
}

// 3.做一些准备工作
//设置编码。
//为了避免出现乱码，我们通常将数据库编码，php文件编码，和html的meta中的编码设置成一样
mysql_query("SET NAMES utf8",$dbLink);
//屏蔽宽字符集漏洞
mysql_query("SET character_set_client=binary",$dbLink);

// 4.写一个修改的sql查询语句
$password=md5("123456");
$user_id=1;
$sql="
	update 
		user
	set 
		password='".$password."'
	where
		id='".$user_id."';
";

echo $sql;
echo "<br>";

// 5. 进行查询，并返回查询句柄
$queryLink=mysql_query($sql,$dbLink);
if(mysql_errno($dbLink)!=0){//若存在查询错误
	 exit(mysql_errno ($dbLink).": ".mysql_error ($dbLink));
}
</textarea>

	(4)删除
<textarea>
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国


// 1. 连接数据库服务器，产生句柄。用@屏蔽错误
$dbLink=@mysql_connect("127.0.0.1","root","");
if(empty($dbLink)){
	exit("连接数据库失败");
}

// 2. 在服务器上，选择数据库。
//可以不带连接句柄变量，若不带，为最新连接的数据库
$dbSelect=@mysql_select_db("my_item",$dbLink);
if(empty($dbSelect)){
	exit("数据库选择失败");
}

// 3.做一些准备工作
//设置编码。
//为了避免出现乱码，我们通常将数据库编码，php文件编码，和html的meta中的编码设置成一样
mysql_query("SET NAMES utf8",$dbLink);
//屏蔽宽字符集漏洞
mysql_query("SET character_set_client=binary",$dbLink);

// 4.写一个删除的sql查询语句
$user_id=2;
$sql="
	delete 
		from user
	where
		id='".$user_id."';
";

echo $sql;
echo "<br>";

// 5. 进行查询，并返回查询句柄
$queryLink=mysql_query($sql,$dbLink);
if(mysql_errno($dbLink)!=0){//若存在查询错误
	 exit(mysql_errno ($dbLink).": ".mysql_error ($dbLink));
}
</textarea>
</pre>
</li>


<li>
<b class="hs_2">7.多表关系和高级sql语句</b>
<pre class="hs_2_son">
1)在项目，通常表间都有关系。若一张表，和别的表完全没有关系，这种的情况基本是不存在的。除非是最简单的日志表
2)多表关系
(1)1对1的表关系
	例如：有时候，有可能将blog内容表分成2张，
	1张是原blog_content表，但将contents字段删除
	第2张是blog_content_more表，2个字段：
		blog_content_id：blog_content表的，自增字段
		contents：blog的内容字段

	看起来，主要是将contents字段，从blog_content表移动到了blog_content_more表
	<b>原因是</b>：考虑到contents字段内容可能比较多，有时候并不是需要得到内容，只是需要得到blog内容的标题就可以了
		所以将其分离出去，让blog_content表变得小，当在仅需要得到标题时，查询blog_content表会变得快

	<b>但若想同时获得标题和内容时怎么办</b>：使用多表关联查询
		先手工分表，给学生看。然后运行下述sql语句。可以在phpMyAdmin中运行
		<b>内联接查询</b>
			$sql="
					select *
					from 
						blog_content,
						blog_content_more
					where
						blog_content.id=blog_content_more.blog_content_id
				";
			上述sql语句说明了，查询2张有关系的表
			并将2张表的关系说明。
			这里的关系，用字段表明就是：blog_content表的.id字段，和blog_content_more表的.blog_content_id字段相同
			这也说明了，表间关系，是用字段来表达的
			blog_content_more表中的blog_content_id字段，就好像：
				blog_content_more表中，每一条记录，都持有blog_content表的身份证号(主键字段的值)
				虽然我，blog_content_more表没有身份证号，但是通过blog_content表的身份证号，可以查询到我的
				我本身其实是blog_content_more表的附属品，没有必要存在自己独立的身份证号，
				平时我也不会单独被别人用到，我只会在blog_content表需要我帮助的时候，才根据条件，跟随它的每一条记录显示出来

				开玩笑说：你老婆是你的附属品，她说我不想独自出门。当然你需要我陪你时，我可以随你。如果真的有人单独要找我，请他找你就行了。
				当然，这需要你老婆心里有你，心里有你的一种标识，无论是什么。如果她心里没有你，你知道的，你们就没有关系了，完全谈不上1对1的关系表

	<font color=red>1对1的关系表
	1张是主表，1张是副表
	它们的关系，记录在副表上
	副表上有一个字段，记录了主表的主键信息</font>
			
		<b>左联接查询</b>
			用左联接也可以完成这种关系的查询
			
			$sql="
					select *
					from 
						blog_content
						left join blog_content_more
							on blog_content.id=blog_content_more.blog_content_id
				";

			在语法上的差别，使用了left join，并将关系，从where中移动到 on 后面
			在结果上的差别：
				若副表的信息丢失了。主副表的关系也就不存在
				这时查询主表的时
					<font color=red>若用内联接，则：丢失副表信息的，那些主表信息，也查询不出来了
					若用左联接，则：丢失副表信息的，那些主表信息，可以查询出来，仅仅是副表字段为null</font>
					测试给学生看一下

			开玩笑说：老婆离异了。内联接连老公都查不出来了。左联接还可以查出来老公

		<font color=red>左联接速度明显慢于内联接，在业务上不需要精确查询时，可使用内联接。例如电商网站的新闻列表</font>

		<b>子查询</b>
			用子查询也可以完成这种关系的查询

			$sql="
				select 
					bc.id as idid,
					bc.title title_title,
					(
						select 
							bm.contents
						from
							blog_content_more as bm
						where
							bm.blog_content_id=bc.id
							
					) contents
				from
					blog_content bc
			";
			<font color=red>这里使用了表别名，和字段别名，可以用as或者空格
			当前的子查询，放在了select子句中，并且在子查询中，要表明子查询，和外面的主查询的关系
			不存在和外部主查询没有关系的字查询</font>

			<font color=red>一般来说，子查询能完成的，左联接和内联接可以完成，但是写起来比较麻烦，而且理解上也没有子查询那么方便
			子查询，可以放在select/from/where 不同的子句内
			当放在，from，where子句中，速度是最慢的</font>


<div class="homework homework_div">
		作业：
		1.建立1张用户联系方式表：user_contact，和user表是1对1的关系。user_contact表中字段有移动电话/qq/个人博客地址
		2.用上述3种查询方式，写出1对1关系表的sql语句，并测试结果
		<span class="answer">答案</span>：略
</div>

(2)1对多的表关系

比较常见的业务：
	blog分类表，和blog内容表
	新闻分类表，和新闻内容表
	商品分类表，和商品表
	订单表，和订单商品表
	用户表，和其他相关表，如：新闻表/商品表/blog表等

	建立blog分类表：blog_type
	id:整形/无正负/主键自增
	name:20个不定长字符

	插入一些分类名称

	当前能否用sql语句将blog_type和blog_content 两张表内容查出来呢？
	不行！
	因为当前它们还没有设置关系！！！

	开玩笑说，1对多，好像1夫多妻。如果每个老婆心里都没有你，那么，就分飞了吧
	
	所以1对多的表关系，关系也是记录在“多”那张表上
	在blog_content表中增加字段，blog_type_id字段，整形，无正负，索引

	内联接
	$sql="
		select *
		from
			blog_type t,
			blog_content c
		where
			t.id=c.blog_type_id
			
	";

	左联接
	$sql="
		select *
		from
			blog_type t
			left join blog_content c
				on t.id=c.blog_type_id
	";

	子查询
	$sql="
		select 
			c.*,
			(
				select t.name
				from blog_type t
				where t.id=c.blog_type_id
			) blog_type_name
		from
			blog_content c
	";

	2张以上表查询
	内联接
	$sql="
		select *
		from
			blog_type t,
			blog_content c,
			blog_content_more m
		where
			t.id=c.blog_type_id
			and c.id=m.blog_content_id
		order by
			t.id,
			c.id desc
			
	";

	左联接
	$sql="
		select *
		from
			(
			 blog_type t
				left join blog_content c
					on t.id=c.blog_type_id
			)left join blog_content_more m
				on c.id=m.blog_content_id

	";

	子查询
	$sql="
		select 
			c.*,
			t.*,
			(
				select m.contents
				from blog_content_more m
				where t.id=m.blog_content_id
			)blog_content_more
		from
			 blog_type t
				left join blog_content c
					on t.id=c.blog_type_id
			
	";

<div class="homework homework_div">
		作业：
		1.user和blog_content，是1对多的，1个用户有多条blog内容。请用3种sql语句，同时查询这2张表
		2.创建具备1对多关系的2张表，要有业务意义
		<span class="answer">答案</span>：略
</div>

(3)多对多的表关系

建立一张用户爱好表：user_hobby
2个字段
id:整形，不区分正负，主键
hobby:20位不定长，索引

建立一张用户和用户爱好的关联表：user2hobby
2个字段
user_id:用户id
user_hobby_id:用户爱好id
<font color=red>这2个字段是，联合唯一</font>

插入一些记录

当前，user和user_hobby是一种多对多的关系表
它们的关系记录在另外一种中间表内：user2hobby
<font color=red>这张中间表里，记录了双方的主键，记录了双方之间的关系</font>

这种多对多的关系，好像2个方向的1对多
从user表看，1个用户，有多个爱好，user和user_hobby是1对多的关系
从user_hobby表看，1个爱好，可以属于多个用户，user_hobby和user是1对多的关系

开玩笑说：有一个红娘，四处在给人做媒。她会将1个男方，介绍给多个女方；也会将1个女方，介绍给多个男方
对于男方说，他知道，他有多个被介绍的女方可选择
对于女方说，她知道，她有多个被介绍的男方可选择
但是只有红娘手上有一本账，知道男、女双方当前多对多的关系。红娘手上的账本，就是多对多中间表

//想要知道id是1的用户的爱好
$sql="
	select 
		*
	from 
		user a,
		user_hobby b,
		user2hobby c
	where
		a.id=c.user_id
		and b.id=c.user_hobby_id 
		and a.id=1

";
<font color=red>2张表要写好1个关联关系，3张表要写好2个关联关系。n张表要写好n-1个关联关系。
之后再写上业务上的其他要求。这样不容易忘记写关联关系</font>

比较常见的业务：
	用户和爱好
	商品和关键词
	新闻和关键词
	图书和作者

<div class="homework homework_div">
		作业：
		用数据表建立图书和作者的多对多关系，并写出sql语句
		<span class="answer">答案</span>：略
</div>

(4)单表1对多关系。父子关联表。无限分级表

建立一张城市表city，(<font color=red>表数据在item文件夹下city sql文件，请导入</font>)

city表本身是一个父子关联表
其中class_id字段代表主键，通过该字段能找的唯一一个省，或者市，或者区
class_parent_id字段代表，某一条记录的父亲的id。这样，就能通过查询一个父亲的id，找到所有儿子
	例如，当知道安徽的主键id是3时，可以查询出安徽下的所有儿子城市。写sql语句测试给学生看

这也是个1对多的关联表
1个省，对多个市
1个市，对多个区
它将1对多的关联关系，记在自己表新加的字段上：父id
当前，它也可以拆分成3张表：省/市/区

这种单表的父子关联表好处在于
(1)减少表数量
(2)可以保存无限分类的关系。无限分类，将在项目课说到
<div class="homework homework_div">
		作业：
		1.将这张城市表，拆分成3张表。只需要表结构对就可以
		2.有一个页面中，已知省的id是3，请用ajax请求，在页面上显示它的下级所有市
		3.扩展：将显示的所有市，以select表单域的方式显示
		4.扩展：做出省/市/区，联动select表单域。当选择省，就能显示出下级市，当选择市就能显示下级区
		<span class="answer">答案</span>：
		<textarea>

/////////////////////显示页面


<meta charset='utf-8'>
<!-- !!!请加载正确的jquery路径！！！ -->
<script src="./../ajax/js/jquery-1.7.1.js"></script>
<script>
function page_getCity(e,id){
//$.ajax是jquery的一个函数。
			//用它可以进行ajax请求。
			//它的参数是一个对象。
			//除了以下写法，还有很多其他写法
			$.ajax(
					{
						url: "http://127.0.0.1/example/curd/ajax_get_city.php",//提交到哪个url。要能http访问的
						type: "POST",//提交模式：post/get
						data: {//提交哪些变量。
								//若post模式，则 上述的url，使用$_POST['uname']接收
								//若get模式，则 上述的url，使用$_GET['uname']接收
								'id':id,//
								'tmp':Math.random() //产生随机数，防止有缓存影响。当前可不加
							},

						async: true,//true/false:异步(默认)/同步：
									//异步，则等待服务端返回值时，当前页面不僵住
									//同步，则等待服务端返回值时，当前僵住

						dataType: "json",//服务端数据返回格式。包括：json/html/script/text/xml

						success: function(data){//服务端 返回值的处理
							if(data.code<0){
								alert(data.info);
							}else{
								e.html(data.info);
							}

						}
					}
				);
}

$(document).ready(
	function (){
		page_getCity($("#proId"),1)



		$("#proId").bind(
								"change",
								function (){
									page_getCity($("#cityId"),$("#proId").val());

									$("#areaId").html("");
								}
		)

		$("#cityId").bind(
								"change",
								function (){
									page_getCity($("#areaId"),$("#cityId").val());
								}
		)
	}
)
</script>

<select  id="proId" name="proId">
</select>
<br>
<select  id="cityId" name="cityId">
</select>
<br>
<select  id="areaId" name="areaId">
</select>







//////////////ajax响应页面ajax_get_city.php
<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国

$id=!empty($_POST['id'])?$_POST['id']:1;


// 1. 连接数据库服务器，产生句柄。用@屏蔽错误
$dbLink=@mysql_connect("127.0.0.1","root","");
if(empty($dbLink)){
	echo json_encode(array('code'=>-1,'info'=>"连接数据库失败"));
	exit;
}

// 2. 在服务器上，选择数据库。
//可以不带连接句柄变量，若不带，为最新连接的数据库
$dbSelect=@mysql_select_db("my_item",$dbLink);
if(empty($dbSelect)){
	echo json_encode(array('code'=>-2,'info'=>"数据库选择失败"));
	exit;
}

// 3.做一些准备工作
//设置编码。
//为了避免出现乱码，我们通常将数据库编码，php文件编码，和html的meta中的编码设置成一样
mysql_query("SET NAMES utf8",$dbLink);
//屏蔽宽字符集漏洞
mysql_query("SET character_set_client=binary",$dbLink);

// 4.获得所有省
$sql="
	select * 
		from city
	where
		class_parent_id='".$id."';
";


// 5. 进行查询，并返回查询句柄
$queryLink=mysql_query($sql,$dbLink);
if(mysql_errno($dbLink)!=0){//若存在查询错误
	// exit(mysql_errno ($dbLink).": ".mysql_error ($dbLink));
	echo json_encode(array('code'=>-3,'infot'=>mysql_errno ($dbLink)));
	exit;
}

//$proList=array();
$data=array('code'=>1,'info'=>"");
$data['info']='<option value="">请选择</option>'."\n";
while ( $row  =  mysql_fetch_array($queryLink,MYSQL_ASSOC)) {
	//$proList[]=$row;

	$data['info'].='<option value="'.$row['class_id'].'">'.$row['class_name'].'</option>'."\n";
	
}
	echo json_encode($data);
?>

</textarea>
</div>

(5)分组聚合语句
	<font color=red>求user表总条数</font>
	-------------------
	select
		count(*) as countAs
	from 
		user
	<font color=red>使用mysql的count函数，求总条数，经常用</font>

	求user表男生女生，各多少人
	-------------------
	select
		sex,
		count(*) as countAs
	from 
		user
	group by
		sex
	<font color=red>使用group by 子句，对性别分组
	然后使用mysql的count函数，求每组总条数</font>
		


	若有成绩表results，字段：
	========================
	user_id
	subject_id：科目id
	classes_id:班级id
	fraction:分数

	求每个科目的平均分
	------------------
	select
		subject_id,
		avg(fraction) avg
	from 
		results
	group by
		subject_id
	<font color=red>使用group by 子句，对科目分组
	然后使用mysql的avg函数，求分数字段的平均值</font>

	求每个班级，每个科目的平均分
	----------------------
	select
		classes_id,
		subject_id,
		avg(fraction) avg
	from 
		results
	group by
		classes_id,
		subject_id
	<font color=red>使用group by 子句，对多字段分组</font>


	求每个学生的平均分
	----------------------
	select
		user_id,
		avg(fraction) avg
	from 
		results
	group by
		user_id


	求平均分，大于90分的那些学生
	----------------------
	select
		user_id,
		avg(fraction) avg
	from 
		results
	group by
		user_id
	having 
		avg >90
	<font color=red>having 子句，可以对分组后的结果，进行筛选
	放在group by 子句后面</font>


(6)子查询所在位置
	1)select子句中：
	(1)结果集：只能是1个字段/且只能是1条记录，否则要用limit 1
	(2)扩展主查询的字段：如获得某个关联id的实际名称。查询blog内容表时，想获得分类名称。相当于联表查询
	(3)或者，扩展主查询的字段：是某些表的统计结果：主查询为某时间段的统计结果，同比本表其他时间段的统计结果/或者其他表统计结果

	2)from子句中：
	(1)结果集：可以是多字段、多条。相当于1张表
	(2)子查询的，普通查询结果作为另外一张表。如最近一周回复blog主题的用户，他们是针对哪些blog主题发出的回复。相当于联表查询
	(3)子查询的，统计查询结果作为另外一张表。商品数最多的前3名订单，是哪些用户购买的

	案例：
	最近一周回复blog主题的那些用户，他们是针对哪些blog主题发出的回复

	建立一张blog回复表：blog_content_replay。字段：
	id:
	blog_content_id
	replay_content
	add_user_id
	add_time


	$time1=date("Y-m-d 00:00:01",strtotime("-7 day",time()));
	$time2=date("Y-m-d 23:59:59");

	select
		a.add_user_id as replay_user_id,
		b.*
	from(
			select
				DISTINCT blog_content_id, #DISTINCT 去除重复
				add_user_id 
			from 
				blog_content_replay
			where
				add_time between '".$time1."' and '".$time2."'
		)a,
		blog_content b
	where
		a.blog_content_id=b.id
	

	3)where子句中
	(1)结果集：通常只能是1个字段。或者通常是1条记录/有时可以使用多条(in)
	(2)主查询的某个字段条件，要满足子查询的查询结果(非统计)。相当于联表查询
	(3)主查询的某个字段条件，要满足子查询的统计结果(count/max/sum)：
	
	案例：
	求出：回复数量最多那个blog主题，它包含哪些回复
	SELECT
		* 
	FROM
		blog_content_replay 
	WHERE 
		blog_content_replay.blog_content_id
			IN (

					SELECT  a.blog_content_id
					FROM (

							SELECT blog_content_id,count(*)AS countAs
							FROM blog_content_replay
							GROUP BY blog_content_id
							order by countAs desc limit 1
					) a

				)



	(或者求：商品数最多的那个订单，所包含哪些商品)
	(
		打开 快餐项目 数据库(myshopkuaican)，运行以下代码

		SELECT
			* 
		FROM
			sn_foodorderext 
		WHERE 
			sn_foodorderext.oid
				IN (

						SELECT  a.oid
						FROM (

								SELECT count(*)AS countAs, sn_foodorder.oid
								FROM sn_foodorder ,sn_foodorderext 
								WHERE sn_foodorder.oid= sn_foodorderext.oid
								GROUP BY sn_foodorder.oid
								order by countAs desc limit 1
						) a

					)
	)

<div class="homework homework_div">
		作业：
		使用user2hobby表

		1.求出：爱好最多那个用户，他有哪些爱好

		已知：a用户id为1
		2.总题目为：求出：与a用户爱好相关性最高的，那些用户
		分步解答
		2.1：用sql语句，求出a用户，所有爱好id
		2.2：求：在a用户爱好范围内的，其他用户
		2.3：求：上述用户，爱好在a用户范围内，的爱好总数

		3.总题目为：和a用户爱好相关性 大于50% 比例的 用户有哪些
		分步解答
		3.1：使用第一题的答案sql，作为主sql，其中用户爱好数若为：y
		3.2：求：a用户爱好总数：x
		3.3：将2.2的sql，作为2.1 sql的select中的子查询，让 y/x 并as为z，并且让having z > 0.5
		
		<span class="answer">答案</span>：
		<textarea>
1.

SELECT
	* 
FROM
	user2hobby 
WHERE 
	user2hobby.user_id
		IN (

				SELECT  a.user_id
				FROM (

						SELECT user_id,count(*)AS countAs
						FROM user2hobby
						GROUP BY user_id
						order by countAs desc limit 1
				) a

			)

2.

select 
	user_id,
	count(*) hobbyNum
from 
	user2hobby
where
	user_id in (

			SELECT 
				DISTINCT user_id
			FROM 
				user2hobby
			WHERE 
				`user_hobby_id`
					IN (

						SELECT DISTINCT `user_hobby_id`
						FROM `user2hobby`
						WHERE user_id =1
					)
				AND user_id !=1
)
and 
	`user_hobby_id` in (
		
		SELECT DISTINCT `user_hobby_id`
		FROM `user2hobby`
		WHERE user_id =1
	)
group by 
	user_id
order by 
	hobbyNum desc


3.
select 
	user_id,
	(
		count(*) /
			(
				SELECT count(*)
				FROM `user2hobby`
				WHERE user_id =1
			)
	) as num05
from 
	user2hobby
where
	user_id in (

			SELECT 
				DISTINCT user_id
			FROM 
				user2hobby
			WHERE 
				`user_hobby_id`
					IN (

						SELECT DISTINCT `user_hobby_id`
						FROM `user2hobby`
						WHERE user_id =1
					)
				AND user_id !=1
)
and 
	`user_hobby_id` in (
		
		SELECT DISTINCT `user_hobby_id`
		FROM `user2hobby`
		WHERE user_id =1
	)
group by 
	user_id
having 
	num05>0.5
order by 
	num05 desc


		</textarea>
</div>

	

(7)replace into语句
	代表:先删后插
	表本身要有唯一字段
	sql写法如下：
	$sql="
		replace into
			a
		set
			a1=1,
			a2=2
	";
	若a1字段是唯一字段，则插入时，若存在a1=1的字段，则这条记录将被删除，然后再插入本条记录

(8)多表删除
	若多表间有关联，则可以象select语句那样，将关联关系写好，把满足条件的多表记录一起删除

	同时删除：博客内容表和博客内容详情表，只要满足博客内容的类别是1
	$sql="
		delete blog_content ,blog_content_more 
		from
			blog_content ,
			blog_content_more 
		where
			blog_content.id=blog_content_more.blog_content_id
			and blog_content.blog_type_id=1
	
	";
	也可以左联接
	$sql="
	
		delete blog_content ,blog_content_more 
		from
			blog_content 
			left join blog_content_more 
				on blog_content.id=blog_content_more.blog_content_id
		where
			blog_content.blog_type_id=1
	";
	也可以子查询，只要子查询里，不包含要删除的表

	此外可以带limit，只删除满足条件的前几条


(9)sql常用语法，和子句顺序
select count/sum/min/max/avg 
from:单表，多表
left join on:
where :and /or/ between and / in /like/not like/=/!= , is null / is not null
group by 字段,字段
having
order by asc/desc/ Rand
limit

UNION ALL
CONCAT 
CAST
FIND_IN_SET
	 FIND_IN_SET( 2, content )
	 FIND_IN_SET( id, '22,24' )
</pre>
</li>

<li>
<b class="hs_2"><font color=red>8.数据库设计三大范式</font></b>
<pre class="hs_2_son">
为了让数据表设计的更加合理(存储上，而非业务上)，有三大范式可以学习

1)第一范式：定义字段
---------------------
字段不可再分（原子性）
从业务上看：某订单配送地址表()，要不要省市2个字段
从表现上看：非主键字段内容，不应当有重复。否则创建新字段

第二范式：通过定义主键，以及和非主键关系，来确定是否分表
------------
必须有主键。根据主键能确定唯一一条记录。
如果是联合主键：
	每个非主键必须和主键完全相关
	联合主键只能完整的确定每一个非主键，而不能联合主键的每一部分，能确定一些非主键

从业务上看：一张表只应该保存一类（种）数据（唯一性/内聚性）

订单表（ 订单编号，订单总价，商品编号，商品名称，数量，单价）：<font color=red>不对
	订单编号，或商品编号，都不能确定一个订单商品
	通过联合主键：订单编号和商品编号 才能确定一个商品
	所以要分成：订单表，和订单商品表</font>

从表现上看：如果需要多个字段来确定一条记录(多字段联合主键)，考虑分表


第三范式：通过定义非主键间关系，来确定是否进行关联引用，或者分表
-----------
非主键字段只依赖于主键，不能依赖于其他非主键
从业务上看：
	从主键往其他字段看：
	只有主键能唯一确定，其他非主键字段。找到主键，就能确定其他字段
	非主键都是主键的附属。
	非主键不能用以去确定其他非主键

学生表(学号，姓名，年龄，性别，所在院校，院校地址，院校电话)：<font color=red>不对
	主键：学号，不能确定：所在院校，院校地址，院校电话
	非主键：所在院校，能确定：院校地址，院校电话
	所以要分成：学生表，院校表</font>

学生分数表（学号，科目1，分数，科目2，分数，科目3，分数）：<font color=red>看实际情况</font>

	从其他字段往主键看
	非主键和主键是直接依赖，而不能是间接依赖
	非主键A不能先，直接依赖非主键B，然后非主键B再直接依赖主键

从表现上看：如果表中的非主键字段内容，还存在于其它表中，考虑分表


===============
总体来看：
1.每个字段最好是数字（原子性）
2.如果数字说明不了业务，则数字是其他表的主键引用（分表）
3.如果无法再产生其他新表，则字段可以使用字符串类型（唯一性）

</pre>
		</li>


<li>
<b class="hs_2">9.索引</b>
<pre class="hs_2_son">
1)索引，是索引字段
2)索引的目的，是让数据库查询更加快
3)索引就好像书的目录。如果一本书没有目录，能不能看，能。容不容易找到相应章节，不容易
4)数据表做索引是必须的
5)每张表的主键字段，或者唯一字段，已经是索引
6)有哪些类型索引。主要是
	(1)主键：PRIMARY
	(2)唯一：UNIQUE
	(3)普通：index
	以及联合索引：几个字段联合做索引

	操作一下做索引给学生看
7)什么字段要做索引？
	where 子句 涉及的字段要做索引
	group by 子句 涉及的字段要做索引
	order by 子句 涉及的字段要做索引

8)做索引有什么要注意的吗
	where子句的查询条件里有 !=，MySQL将无法使用索引。
	where子句使用了Mysql函数的时候，索引将无效，比如：select * from tb where left(name, 4) = 'xxx'
	使用LIKE进行搜索匹配的时候，这样索引是有效的：select * from tbl1 where name like 'xxx%'，而like '%xxx%' 时索引无效

	一看到字段是int的，或者char类型，就要考虑是否要做索引
</pre>
</li>
<li>
<b class="hs_2"><span  style="color:red">10.limit和翻页</span></b>
<pre class="hs_2_son">

裸代码翻页
<textarea>

<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国1


// 1. 连接数据库服务器，产生句柄。用@屏蔽错误
$dbLink=@mysql_connect("127.0.0.1","root","");
if(empty($dbLink)){
	exit("连接数据库失败");
}

// 2. 在服务器上，选择数据库。
//可以不带连接句柄变量，若不带，为最新连接的数据库
$dbSelect=@mysql_select_db("my_item",$dbLink);
if(empty($dbSelect)){
	exit("数据库选择失败");
}

// 3.做一些准备工作
//设置编码。
//为了避免出现乱码，我们通常将数据库编码，php文件编码，和html的meta中的编码设置成一样
mysql_query("SET NAMES utf8",$dbLink);
//屏蔽宽字符集漏洞
mysql_query("SET character_set_client=binary",$dbLink);

// 4.写一个sql查询语句


$typeId=!empty($_GET['typeId'])?(int)$_GET['typeId']:1;

$countNum=0;//总条数
$sql="
	select 
		count(*) as countAs
	from 
		blog_content 
	where
		blog_type_id='".$typeId."'
";
// 5. 进行查询，并返回查询句柄
$queryLink=mysql_query($sql,$dbLink);
if(mysql_errno($dbLink)!=0){//若存在查询错误
	 exit(mysql_errno ($dbLink).": ".mysql_error ($dbLink));
}
while ( $row  =  mysql_fetch_array($queryLink,MYSQL_ASSOC)) {
	$countNum=$row['countAs'];
}

$showNum=3;//每页显示多少条
$pageAll=ceil($countNum/$showNum);//总页码

//当前页码
$page=!empty($_GET['pId'])?(int)$_GET['pId']:1;
if($page > $pageAll){
	$page =$pageAll;
}else if($page<1){
	$page=1;
}


//获得当前页url
$url="http://".$_SERVER["HTTP_HOST"].(($_SERVER["SERVER_PORT"]==="80")?"":$_SERVER["SERVER_PORT"]).$_SERVER["PHP_SELF"]."?";

//echo $url;
if(!empty($_GET)) {//如果有get值
	$g=$_GET;

	//将存在的翻页id删除。在循环翻页代码时，会重新组装
	if(isset($g['pId'])) {
		unset($g['pId']); 
	}

	//删除后，重新组装成url问号后面的get参数
	//$url.=http_build_query($g).(empty($g)?'':'&');
	$url.=empty($g)?'':http_build_query($g).'&';
}


$pageLast=$page-1;//上一页
$pageNext=$page+1;//下一页
$pageLast=max($pageLast,1);
$pageNext=min($pageNext,$pageAll);


//limit 开始条数
$limtS=($page-1)*$showNum;


//翻页的html代码
$pageLinkHtml="";


$pageLinkHtml.="<a href='./test.php?pId=1'>第一页</a>&nbsp;\n";

for($i=1;$i<=$pageAll;$i++){
	if($i==$page){
		$pageLinkHtml.=$i."&nbsp;\n";
	}else{
		$pageLinkHtml.="<a href='".$url."pId=".$i."'>".$i."</a>&nbsp;\n";
	}
}

$pageLinkHtml.="<a href='".$url."pId=".$pageLast."'>上一页</a>&nbsp;\n";

$pageLinkHtml.="<a href='".$url."pId=".$pageNext."'>下一页</a>&nbsp;\n";

$pageLinkHtml.="<a href='".$url."pId=".$pageAll."'>最后一页</a>&nbsp;\n";




//////////查询每一页的 多少条
$sql="
		select 
			*
		from 
			blog_content 
		where
			blog_type_id='".$typeId."'

		order by
			id 

		limit ".$limtS.",3
		
";
	
// 5. 进行查询，并返回查询句柄
$queryLink=mysql_query($sql,$dbLink);
if(mysql_errno($dbLink)!=0){//若存在查询错误
	 exit(mysql_errno ($dbLink).": ".mysql_error ($dbLink));
}



?>

<table border=1>

	<tr>
		<td>blog id</td>
		<td>标题</td>
		<td>加入者 id</td>
		<td>加入时间</td>
	</tr>
<?php
// 6. 循环输出结果
//说一下mysql_fetch_array函数的第二个参数
while ( $row  =  mysql_fetch_array($queryLink,MYSQL_ASSOC)) {
?>
	<tr>
		<td><?php echo $row['id']?></td>
		<td><?php echo $row['title']?></td>
		<td><?php echo $row['add_user_id']?></td>
		<td><?php echo $row['add_time']?></td>
	</tr>

<?php
}
?>
</table>

<br>
<?php
echo $pageLinkHtml;
?>

</textarea>


封装成函数 翻页和数据库查询
<textarea>
/////////db.php
<?php
define("dbHost",'127.0.0.1');
define("dbUser",'root');
define("dbPass",'');
define("dbName",'my_item');

//创建数据库连接
function db($dbHost="",$dbUser="",$dbPass="",$dbName=""){
	empty($dbHost) && $dbHost=dbHost;
	empty($dbUser) && $dbUser=dbUser;
	empty($dbPass) && $dbPass=dbPass;
	empty($dbName) && $dbName=dbName;
	
	// 1. 连接数据库服务器，产生句柄。用@屏蔽错误
	$dbLink=@mysql_connect($dbHost,$dbUser,$dbPass);
	if(empty($dbLink)){
		exit("连接数据库失败");
	}

	// 2. 在服务器上，选择数据库。
	//可以不带连接句柄变量，若不带，为最新连接的数据库
	$dbSelect=@mysql_select_db($dbName,$dbLink);
	if(empty($dbSelect)){
		exit("数据库选择失败");
	}

	// 3.做一些准备工作
	//设置编码。
	//为了避免出现乱码，我们通常将数据库编码，php文件编码，和html的meta中的编码设置成一样
	mysql_query("SET NAMES utf8",$dbLink);
	//屏蔽宽字符集漏洞
	mysql_query("SET character_set_client=binary",$dbLink);

	return $dbLink;
}

/*
查询

$dbLink：连接句柄
$sql,
$shift：0/1：返回多条/返回1条
$retype：0/1/2：返回字段类型：数字/名称/两者都有
*/
function db_select($dbLink,$sql,$shift=0,$retype=1){
	//返回字段 类型
	$retype = $retype == 1 ? MYSQL_ASSOC : ($retype == 0 ? MYSQL_NUM : MYSQL_BOTH);

	//初始化结果集
	$array=array();

	//查询结果，资源类型
	$result = @mysql_query($sql,$dbLink);

	$error=mysql_error($dbLink);
	if(!empty($error)){
		exit(mysql_errno($dbLink).":".mysql_error($dbLink));

	}else{
		
		//循环内存查询结果(资源类型)，并放入数组
		while($row = mysql_fetch_array($result,$retype)){
			$array[] = $row;
		}

		//释放内存查询结果
		mysql_free_result($result);

		
		if($shift==1){//如果只需要1条
			!empty($array) && $array = array_shift($array);
		}else if($shift==-1){//如果只需要1条的1个字段
			!empty($array) && $array = array_shift($array);
			$array=current($array) ;

		}
		
	}

	//返回结果集
	return $array;
}


//执行其他操作
function db_execute($dbLink,$sql){
	@mysql_query($sql,$dbLink);

	$error=mysql_error($dbLink);
	if(!empty($error)){
		exit(mysql_errno($dbLink).":".mysql_error($dbLink));
	}
}

//获得最后id
function db_last_id($dbLink){
	return mysql_insert_id($dbLink);
}

//获得影响行数
function db_affected_rows($dbLink){
	return mysql_c_rows($dbLink);
}

/////////////page.php
<?php
/*
$allNum 总条数
$showNum 每页显示多少条
*/
function page_link($allNum,$showNum,$pId="pageId"){
	//总页码
	$pageAll=ceil($allNum/$showNum);

	//当前页码
	$pageNow=!empty($_GET[$pId])?(int)$_GET[$pId]:1;
	if($pageNow > $pageAll){
		$pageNow =$pageAll;
	}else if($pageNow<1){
		$pageNow=1;
	}

	//url地址
	$url="http://".$_SERVER["HTTP_HOST"].(($_SERVER["SERVER_PORT"]==="80")?"":$_SERVER["SERVER_PORT"]).$_SERVER["PHP_SELF"].'?';

	if(!empty($_GET)) {//如果有get值
		$g=$_GET;

		//将存在的翻页id删除。在循环翻页代码时，会重新组装
		if(isset($g[$pId])) {
			unset($g[$pId]); 
		}

		//删除后，重新组装成url问号后面的get参数
		//$url.=http_build_query($g).(empty($g)?'':'&');
		$url.=empty($g)?'':http_build_query($g).'&';
	}

	$pageLast=$pageNow-1;//上一页
	$pageNext=$pageNow+1;//下一页
	$pageLast=max($pageLast,1);
	$pageNext=min($pageNext,$pageAll);

	
	//limit 开始条数
	$limtS=($pageNow-1)*$showNum;

	$html="";
	
	//$html.="<a href='./test.php?pId=1'>第一页</a>&nbsp;\n";

	for($i=1;$i<=$pageAll;$i++){
		if($pageNow==$i){
			$html.=$i."&nbsp;";
		}else{
			$html.= "<a href='".$url.$pId."=".$i."'>".$i."</a>&nbsp;";
		}

	}

	$html.="<a href='".$url.$pId."=".$pageLast."'>上一页</a>&nbsp;\n";
	$html.="<a href='".$url.$pId."=".$pageNext."'>下一页</a>&nbsp;\n";
	//$html.="<a href='".$url.$pId."=".$pageAll."'>最后一页</a>&nbsp;\n";




	return array($html,$limtS);
}
?>






//////testDbPage.php
<?php
header('Content-Type: text/html; charset=UTF-8');//本文件自身编码必须是utf-8
error_reporting(6143);//自己定义错误日志中应该显示6143.
@ini_set('display_errors', 1);//屏蔽错误信息
@date_default_timezone_set('PRC');//设置时区为中国1

//载入数据库连接
require_once(dirname(__FILE__)."/lib/db.php");
//载入翻页
require_once(dirname(__FILE__)."/lib/page.php");

//数据库连接
$dbLink=db();

//查询总条数
$countNum=0;//总条数
$sql="
	select 
		count(*) as countAs
	from 
		blog_content 
";
$countNum=db_select($dbLink,$sql,-1);

//获得翻页代码，和limit开始条数
$showNum=3;//每页显示多少条
list($pageLinkHtml,$limtS)=page_link($countNum,$showNum);


//////////查询每一页的 多少条
$sql="
		select 
			*
		from 
			blog_content 

		order by
			id 

		limit ".$limtS.",".$showNum."
		
";
$list=db_select($dbLink,$sql);
?>

<table border=1>

	<tr>
		<td>blog id</td>
		<td>标题</td>
		<td>加入者 id</td>
		<td>加入时间</td>
	</tr>
<?php
// 6. 循环输出结果
foreach ( $list as $row) {
?>
	<tr>
		<td><?php echo $row['id']?></td>
		<td><?php echo $row['title']?></td>
		<td><?php echo $row['add_user_id']?></td>
		<td><?php echo $row['add_time']?></td>
	</tr>

<?php
}
?>
</table>

<br>
<?php
echo $pageLinkHtml;
?>
</textarea>
</pre>
</li>

<li>
<b class="hs_2">11.数据库常用函数</b>
<pre class="hs_2_son">
	字符串：
	-------------------------
	<b>substr</b>：字符串截取/left/right
	<b>concat</b>：字符串连接
	md5:

	数字
	------------------------
	<b>round</b>：四舍五入
	<b>floor</b>：取最大整数
	mod：取余数
	sign：负/0/正：-1/0/1

	日期
	--------------------------
	<b>FROM_UNIXTIME</b>：把linux时间戳，转换成年月日时分秒
	<b>UNIX_TIMESTAMP</b>：把年月日时分秒，转换成linux时间戳
	Now()：当前时间

	date_add('2012-12-12 12:12:12', interval 1 day);   - 加1天
	date_add('2012-12-12 12:12:12', interval 1 hour);   -加1小时
	date_add('2012-12-12 12:12:12', interval 1 minute);    - 加1分钟
	date_add('2012-12-12 12:12:12', interval 1 second); -加1秒
	date_add('2012-12-12 12:12:12', interval 1 microsecond);-加1毫秒
	date_add('2012-12-12 12:12:12', interval 1 week);-加1周
	date_add('2012-12-12 12:12:12', interval 1 month);-加1月
	date_add('2012-12-12 12:12:12', interval 1 quarter);-加1季
	date_add('2012-12-12 12:12:12', interval 1 year);-加1年
	date_add('2012-12-12 12:12:12', interval '01:15:30' hour_second) );-加上1小时15分30秒（看参数说明）
	date_add('2012-12-12 12:12:12', interval '1 01:15:30' day_second);-加1天1小时15分30秒

	date_sub('2012-12-12 12:12:12', interval '1 1:1:1' day_second) 减

	//ADDDATE
	//ADDTIME

	日期格式 计算时间差
	TIMESTAMPDIFF(MONTH,'2012-12-12 12:12:12','2013-12-12 12:12:12')：
	SECOND 秒
	MINUTE 分钟
	HOUR 小时
	DAY 天
	MONTH 月
	YEAR 年
	天：To_Days(end_time) - To_Days(start_time);

	datediff：日期差
	timediff：时间差
	TIMESTAMP：时间和

	linux格式 计算时间差 (1970-01-01 00:00:00)
	秒：
	分钟：
	小时：
	时分秒：SEC_TO_TIME(end_time - start_time);
	月：
	年：
	//DATE_FORMAT(FROM_UNIXTIME(sum(UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time))),'%d天%H小时%i分钟%s秒')

	DATE_FORMAT：格式化，看参数说明
	MAKEDATE：根据年份和天数，返回哪一天/ To_Days
	LAST_DAY：本月最后一天
	WEEK：某一天是第几周

	控制结构
	---------------
	Ifnull
	If
	case
	group_concat( Convert(concat(shopid,',',money,',',shoptype),char) separator '|')
	SELECT LPAD(UserID,5,0) as id FROM tuser t;//补零

</pre>
</li>

<li>
<b class="hs_2">12.其他</b>
<pre class="hs_2_son">
	1)用sql语句复制数据表：insert into select
		用phpMyAdmin操作看一下sql语句
	2)
	备份数据库
	(1)拷贝数据库文件备份
		若使用MyISAM引擎，则可以直接拷贝数据库文件。mysql/data/下每个数据库目录
	(2)使用sql文件备份
		(1)命令行全库导出:转到mysql/bin目录，键入以下并回车
			mysqldump -uroot -p  my_item >my_item.sql
		(2)使用sql语句单表导出：SELECT...INTO OUTFILE
			SELECT * FROM my_item #可以加where条件，可以选择字段，不用*
			INTO OUTFILE 'c://a.sql' #文件在硬盘绝对路径
			FIELDS TERMINATED BY ',' #字段用什么分割
			OPTIONALLY ENCLOSED BY '"' #字段用什么包裹
			LINES TERMINATED BY '\n'; #行分隔符
			
			不能覆盖已经存在的文件

	3)还原数据库 
		(1)命令行：转到mysql/bin目录，键入以下并回车
			mysql -u root -p my_item2< my_item.sql
			这个my_item2库，要存在
		(2)使用sql语句单表导入：LOAD DATA INFILE
			load data infile 'c://a.sql' #文件在硬盘绝对路径
			IGNORE  into  #ignore：如果有重复唯一键，跳过/也可以用replace into：如果有重复唯一键，替换
			user2 #表名  
			fields terminated by ',' #字段用什么分割
			enclosed by '"' #字段用什么包裹
			LINES TERMINATED BY '\n' #行分隔符
			#IGNORE  2 LINES #忽略前几行
			(testuseid ,testmore ,testmore2 ,LastWorkTime, LastWorkUseId ) #实际要插入哪些字段
			set addtime=now() #使用set 为字段单独赋值

	4)使用phpmyadmin修复和优化表，并查看sql语句

	5)用explain分析sql查询语句
		如：explain select * from user where id=1

		结果说明如下：
		<textarea>
Table：显示这一行的数据是关于哪张表的
possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句
key：实际使用的索引。如果为NULL，则没有使用索引。MYSQL很少会选择优化不足的索引，此时可以在SELECT语句中使用USE INDEX（index）来强制使用一个索引或者用IGNORE INDEX（index）来强制忽略索引
key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好
ref：显示索引的哪一列被使用了，如果可能的话，是一个常数
rows：MySQL认为必须检索的用来返回请求数据的行数
type：这是最重要的字段之一，显示查询使用了何种类型。从最好到最差的连接类型为system、const、eq_reg、ref、range、index和ALL
nsystem、const：可以将查询的变量转为常量.  如id=1; id为 主键或唯一键.
neq_ref：访问索引,返回某单一行的数据.(通常在联接时出现，查询使用的索引为主键或惟一键)
nref：访问索引,返回某个值的数据.(可以返回多行) 通常使用=时发生
nrange：这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西，并且该字段上建有索引时发生的情况 (注:不一定好于index)
nindex：以索引的顺序进行全表扫描，优点是不用排序,缺点是还要全表扫描
nALL：全表扫描，应该尽量避免
Extra：关于MYSQL如何解析查询的额外信息，主要有以下几种
nusing index：只用到索引,可以避免访问表. 
nusing where：使用到where来过虑数据. 不是所有的where clause都要显示using where. 如以=方式访问索引.
nusing tmporary：用到临时表
nusing filesort：用到额外的排序. (当使用order by v1,而没用到索引时,就会使用额外的排序)
nrange checked for eache record(index map:N)：没有好的索引
		</textarea>

	6)sql语句优化经验
		<textarea>
从数据库结构做起
字段类型的定义时遵循以下规则:
选用字段长度最小
优先使用定长型
尽可能的定义 “NOT NULL”
数值型字段中避免使用 “ZEROFILL”
如果要储存的数据为字符串, 且可能值已知且有限, 优先使用 enum 或 set
索引的优化至关重要(以下如果没有特殊说明, 均指查询密集的情况)
被索引的字段的长度越小, 该索引的效率越高
被索引的字段中, 值的重复越少, 该索引的效率越高
查询语句中, 如果使用了 “group” 子句, 根据其中字段出现的先后顺序建立多字段索引
查询语句中, 如果使用了 “distinct”, 根据其中字段出现的先后顺序建立多字段索引
“where” 子句中, 出现对同一表中多个不同字段的 “and” 条件时, 按照字段出现的先后顺序建立多字段索引
“where” 子句中, 出现对同一表中多个不同字段的 “or” 条件时, 对重复值最少的字段建立单字段索引
进行 “内/外连接” 查询时, 对 “连接字段” 建立索引
对 “主键” 的 “unique” 索引 毫无意义, 不要使用
被索引字段尽可能的使用 “NOT NULL” 属性
对写入密集型表, 尽量减少索引, 尤其是 “多字段索引” 和 “unique” 索引

查询语句的优化
多多利用 “explain” 查询索引使用情况, 以便找出最佳的查询语句写法和索引设置方案
慎用 “select *”, 查询时只选出必须字段
查询使用索引时, 所遍历的索引条数越少, 索引字段长度越小, 查询效率越高 (可使用 “explain” 查询索引使用情况)
避免使用 mysql 函数对查询结果进行处理, 将这些处理交给客户端程序负责
使用 “limit” 时候, 尽量使 “limit” 出的部分位于整个结果集的前部, 这样的查询速度更快, 系统资源开销更低
在 “where” 子句中使用多个字段的 “and” 条件时, 各个字段出现的先后顺序要与多字段索引中的顺序相符
在 “where” 子句 中使用 “like” 时, 只有当通配符不出现在条件的最左端时才会使用索引
在 mysql 4.1 以上版本中, 避免使用子查询, 尽量使用 “内/外连接” 实现此功能
减少函数的使用, 如果可能的话, 尽量用单纯的表达式来代替
避免在 “where” 子句中, 对不同字段进行 “or” 条件查询, 将其拆分成多个单一字段的查询语句效率更高

索引及查询优化

索引的类型
? 普通索引：这是最基本的索引类型，没唯一性之类的限制。
? 唯一性索引：和普通索引基本相同，但所有的索引列值保持唯一性。
? 主键：主键是一种唯一索引，但必须指定为"PRIMARY KEY"。
? 全文索引：MYSQL从3.23.23开始支持全文索引和全文检索。在MYSQL中，全文索引的索引类型为FULLTEXT。全文索引可以在VARCHAR或者TEXT类型的列上创建。

大多数MySQL索引(PRIMARY KEY、UNIQUE、INDEX和FULLTEXT)使用B树中存储。空间列类型的索引使用R-树，MEMORY表支持hash索引。
单列索引和多列索引（复合索引）
索引可以是单列索引，也可以是多列索引。对相关的列使用索引是提高SELECT操作性能的最佳途径之一。
多列索引：
MySQL可以为多个列创建索引。一个索引可以包括15个列。对于某些列类型，可以索引列的左前缀，列的顺序非常重要。
多列索引可以视为包含通过连接索引列的值而创建的值的排序的数组。一般来说，即使是限制最严格的单列索引，它的限制能力也远远低于多列索引。
最左前缀
多列索引有一个特点，即最左前缀（Leftmost Prefixing）。假如有一个多列索引为key(firstname lastname age)，当搜索条件是以下各种列的组合和顺序时，MySQL将使用该多列索引：
firstname，lastname，age
firstname，lastname

		</textarea>
</pre>
</li>

	<ul>
</div>
<br>

<div id="bio">
	<li>
		<h1>
			<a href="###" style="cursor:point;text-decoration:none;" class="hs_1">第十四部分 异常捕捉try，错误/异常句柄的设置（可放在面对对象时，讲课）</a>
		</h1>
	</li>

	<ul>
		<li>
			<b>1.异常捕捉try定义</b><br>
			将某代码放置在 try 的花括号内，那么该代码中若产生异常，可用 throw 语句抛出，并被 catch语句捕获<br>
			什么叫异常：<br>
			是程序里，程序员人为抛出的一种信息，类似出错信息。<br>
			为什么要抛出这种信息：这是代码设计时，提前考虑到程序可能会出现无法避免的，不合法的运行状态，比如用户上传文件的时候，文件太大，后缀不符合要求。想打开的文件不存在。数据库连接句柄失效等。<br>
			所以，提前做好判断，对不同的不合法，抛出不同的异常，一方面，让异常接收代码接收异常后，尽量使用替代方案修复这种异常，并做好写日志/提示等事情。另一方面，如能修复异常，则让其他部分的程序继续正常执行，而非简单的退出<br>
			php自带异常类：Exception。可被继承

		</li>
		<li>
			<b>2.异常捕捉try示例代码</b><br>
			<textarea>
<?php
header('Content-Type: text/html; charset=UTF-8');
error_reporting(6143);
@ini_set('display_errors', 1);
@date_default_timezone_set('PRC');


try {
	require_once(dirname(__FILE__)."/test.php");

	echo "try块中的，在异常之后，的代码，不会再执行";

	
} catch (Exception $e) {
	
    echo $e->getCode();//异常代码。抛出异常时传的参数
	echo "<br>";
	echo $e->getMessage();//异常说明。抛出异常时传的参数
	echo "<br>";
    echo $e->getFile();//异常文件
	echo "<br>";
    echo $e->getLine();//异常行号
	echo "<br>";
  //  echo $e->getTraceAsString();
//	echo "<br>";
	echo "<pre>";
	print_r($e->getTrace());//异常轨迹



	//可以这里写日志等，
	//或者用替代方案
	//如果觉得是致命异常，可以退出 
}



//只要异常被捕获，捕获块之后的代码，可以正常执行
echo "<br>";

echo 'Hello World<br>';
echo '这是其他运行代码';


//////////////////////////以下是test.php的代码
<?php
function inverse($x) {
	//如果为被除数为0，抛出异常
    if ($x==0) {
		//异常抛出写法：
		//使用throw 抛出
		//抛出的是一个 异常对象。用new 实例化，并传入2个构造参数：异常说明，和异常代码号（这2个参数，会被catch捕获）
        throw new Exception('Division by zero.',11);
    }else {
		return 1/$x;
	}
}


echo inverse(5) . "<br>\n";
echo "-----------------<br>\n";

echo inverse(0) . "<br>\n";

//try块中的，在异常之后，的代码，不会再执行
echo "-----------------<br>\n";
			</textarea>
		</li>
		<li>
			<b>3.错误/异常句柄 定义</b><br>
			如果程序出错了，如何捕获和处理？异常除了使用try将代码括起来，有别的捕获异常的方法吗？<br>
			可以用：错误捕获函数定义：set_error_handler()，和异常捕获函数定义：set_exception_handler()

		</li>
		<li>
			<b>4.错误/异常句柄 代码</b><br>
			<textarea>
<?php
header('Content-Type: text/html; charset=UTF-8');
error_reporting(0);
@ini_set('display_errors', 1);
@date_default_timezone_set('PRC');


//错误捕捉，的回调函数（响应的函数）。
//由错误句柄函数，设置调用它
function errorHandler($errno, $errstr, $errfile, $errline){
	//if( error_reporting()==0){//如果是0，就不操作
	//	return false;
	//}

	echo $errno;//错误号
	echo "<br>";
	echo $errstr;//错误原因
	echo "<br>";
	echo $errfile;//所在文件
	echo "<br>";
	echo $errline;//多少行
	echo "<br>";
	echo "<br>";

	//写日志
	$contents=date("Y-m-d H:i:s")."\n".
						"-----------------------------\n".
						$errno."\n".
						$errstr."\n".
						$errfile."\n".
						$errline."\n".
						print_r($_GET,true)."\n".
						print_r($_GET,true)."\n".
						print_r($_SERVER,true)."\n\n";

	file_put_contents(dirname(__FILE__)."/err_".date("Y-m-d"),$contents,FILE_APPEND | LOCK_EX);
}


class errorHandler{
	public function error($errno, $errstr, $errfile, $errline){
		echo $errno;//错误号
		echo "<br>";
		echo $errstr;//错误原因
		echo "<br>";
		echo $errfile;//所在文件
		echo "<br>";
		echo $errline;//多少行
		echo "<br>";
		echo "<br>";

		//echo 'this';
		exit;
	}

	public function __construct(){
		//set_error_handler(array($this,'error')); //可以用对象方式
	}
}
//$errorHandler=new errorHandler;

//设置错误捕捉句柄所响应的函数。//跳过了error_reporting设置，无论怎么设置，只要有一点错，就会捕捉
//错误，是程序的本身的bug，从未被发现。捕捉后，可以继续往下运行程序，只要不退出
set_error_handler('errorHandler'); 
//set_error_handler(array($errorHandler,'error')); //可以用对象方式





//异常捕捉，回调函数（响应的函数）
function exceptionHandler($e){
    echo $e->getCode();//异常代码
	echo "<br>";
    echo $e->getMessage();//异常说明
	echo "<br>";
    echo $e->getFile();//异常文件
	echo "<br>";
    echo $e->getLine();//异常行号
	echo "<br>";
  //  echo $e->getTraceAsString();
//	echo "<br>";
	echo "<pre>";
	print_r($e->getTrace());//异常轨迹
	echo "<br>";
	echo "<br>";

	//写日志
	$contents=date("Y-m-d H:i:s")."\n".
						"-----------------------------\n".
						$e->getMessage()."\n".
						$e->getCode()."\n".
						$e->getFile()."\n".
						$e->getLine()."\n".
						print_r($e->getTrace(),true)."\n".
						print_r($_GET,true)."\n".
						print_r($_POST,true)."\n".
						print_r($_SERVER,true)."\n\n";

	file_put_contents(dirname(__FILE__)."/exce_".date("Y-m-d"),$contents,FILE_APPEND | LOCK_EX);
}



//设置异常捕捉句柄所响应的函数
//异常，是程序里，程序员人为抛出的，是已知用户有可能不合理的操作。比如上传的时候，文件太大，后缀不符合要求
//但不简单的exit，而是抛出异常，让异常捕捉函数处理。程序不可再往下运行了
set_exception_handler('exceptionHandler');
//set_exception_handler(array($this,'exceptionHandler'));//可以用对象方式




require_once(dirname(__FILE__)."/test2.php");


//如果没有异常抛出，只有错误，则下面还能运行
echo "<br>";
echo 'foot';


//////////////////////////以下是test2.php的代码
<?php

echo aaa; //没有引号

echo "<br>";

$a=array('a'=>'abc');

echo $a[a];//没有引号

echo 1/0;//被除数不能为0

class a{
}
$a=new a;
echo $a;//不能把对象当字符串输出


//throw new Exception('a1',1); //人为抛出错误


function x($x){
	if($x<10){
        throw new Exception('a1',1);//人为抛出错误
	}
        throw new Exception('a2',12);//人为抛出错误
}

x(9);
			</textarea>
		</li>
	</ul>
</div>
<br>
<div id="bio">
	<li>
		<h1>
			<a href="###" style="cursor:point;text-decoration:none;" class="hs_1" ><font color=red>第十五部分 建立一个个人blog网站或者企业站</font></a>
		</h1>
	</li>


<ul>
		<li>
<pre>
1.虚拟域名

<textarea>
wamp软件
增加虚拟域名


1.打开 WINDOWS\system32\drivers\etc\host 文件
增加
127.0.0.1 www.my_item.my
保存


2.
用编辑器，打开 wamp/bin/apache/apache2.2.17/conf/httpd.conf
查找：<Directory />
将下面的 Deny from all
改成：Allow from all

查找：httpd-vhosts.conf
将 Include conf/extra/httpd-vhosts.conf 之前的 #删除

保存

3.
用编辑器，打开 wamp/bin/apache/apache2.2.17/conf/extra/httpd-vhosts.conf

将 <VirtualHost 开头的 代码块 全部删除


加上下面 
DirectoryIndex 所在行，不要带换行

<VirtualHost *:80>
 ServerName my_item.my
 ServerAlias *.my_item.my

 ###修改成 你的路径
 DocumentRoot "E:/php/www/my_item"

 ###修改成 你的路径
<Directory "E:/php/www/my_item">
 Options FollowSymLinks IncludesNOEXEC Indexes
 DirectoryIndex index.html index.htm index.php
 AllowOverride None
 Order Deny,Allow
 Allow from all
 php_admin_value safe_mode On
</Directory>
</VirtualHost>



<VirtualHost *:80>
 ServerName 127.0.0.1

 ###修改成 你的路径
 DocumentRoot "E:/wamp/www"

 ###修改成 你的路径
<Directory "E:/wamp/www"> 
 Options FollowSymLinks IncludesNOEXEC Indexes
DirectoryIndex index.html index.htm index.php 
 AllowOverride None 
 Order Deny,Allow 
 Allow from all 
</Directory>
</VirtualHost>
			
			</textarea>


2.在线编辑器 fck
教案目录/fckeditor			//请放在某个网站的根目录下
测试：教案目录/testFck.php	//请放在某个网站的根目录下

3.
1)单人blog的核心业务：展示自己
2)多人blog的核心业务：展示/互动：通过话题/回复/问候
3)论坛的核心业务：话题

4.前台
1)首页：
	分类/推荐文章/浏览数量/
	评论
		$("#Button2").click(function(event) {
			alert(event.pageX);
			alert(event.pageY);
		});
		position:absolute;
		
		<font color=red>$('#replayForm').serialize(),

		是否登陆
		让评论数量+1</font>

	列表图片获得
		正则抽取
		使用字段


	列表显示时：内容处理：将html标签清除

	推荐(随机/相关)/友情链接/博主基本信息

	模板分类菜单，可以作为多人blog的主页

2)业务封装
	(1)基础业务
		#include/home_data.php

		base_header.php：头部基本信息定义
			编码/错误级别/时区/session_start()
			<font color=red>获得和验证blog id 请求</font>

		include/base_data.php：基础业务查询封装
			获得 用户 基本信息
			获得 用户 blog基本信息
			获得 用户 blog菜单(用户自定义blog分类作为菜单(多人blog)。以及默认菜单等)

			<font color=red>？？获得 用户 文章列表</font>

			获得 用户 文章详情
			获得 用户 文章上/下条
			获得 用户 相关文章
			获得 用户 友情链接
			获得 网站版权等信息

			获得 用户 评论(多用户)
			获得 用户 最新访客(多用户)
			获得 默认 blog分类

	(2)页面业务
		action/get_index.php：每个页面的数据查询业务封装
		action/get_newlist.php：
		等等

		action/action_reg.php 注册
		action/action_login.php 登陆


4.后台
1)业务封装
	(1)基础业务
		base_header.php：头部基本信息定义
			编码/错误级别/时区/session_start()
			并根据组，生成菜单，和url权限
				1=>array(),//普通用户组
				9=>array(),//管理员组

			根据组，验证url权限
	
			/include/base_data.php：基础业务查询封装 （同上）
			扩展：多用户：交友圈

	
	(2)页面业务
		/admin/action/get_index.php：每个页面的数据查询业务封装
		等等：

	登陆
		设置组
</pre>
		</li>
	</ul>
</div>
	
</body>
</html>


<script src="js/jquery-1.7.1.js"></script>
<script src="js/prettyPhoto.js"></script>
<script src="js/custom.js"></script>
<script type="text/javascript">
        $(document).ready(function () {
            $(".title_white_r").click(function () {
                var id = this.id;
                id = "#" + id.replace("st", "tc");
                $(id).toggle();
            });
            
        });
 </script>
 <script type="text/javascript">
        $(document).ready(function () {
            $(".ertitle").click(function () {
                var id = this.id;
                id = "#" + id.replace("bt", "nr");
                $(id).toggle();
            });
            
        });
 </script>
 <script>
       $(document).ready(function(){
	        $(".details").click(function(){
			    var id=this.id;
				id="#"+id.replace("sh","de");
				$(id).toggle();
			});
	   });


$(document).ready(
	function (){
		//1级可打开
		//查找1级菜单，的父li，然后将其的兄弟li隐藏
		$(".hs_1").parents('li').next('ul').children('li').hide();
		
		//如果1次菜单被点击，则将其父li的兄弟li显示/隐藏
		$(".hs_1").toggle(
			function (){
				
				$(this).parents('li').next('ul').children('li').show();
			},
			function (){
				$(this).parents('li').next('ul').children('li').hide();
			}
		)

		//2级可打开
		$(".hs_2_son").hide();
		$(".hs_2_son").prevAll('.hs_2').css({cursor:"pointer",color:"blue",fontSize:'15px'});
		$(".hs_2").toggle(
			function (){
				$(this).nextAll(".hs_2_son").eq(0).show();
			},
			function (){
				$(this).nextAll(".hs_2_son").eq(0).hide();
			}
		)

		$("textarea").attr("readonly","readonly")

		//答案可打开
		$(".answer").css({cursor:"pointer",color:"yellow",background:"#000000",fontWeight:"bold",fontFamily:"微软雅黑"});
		$(".answer").nextAll("textarea").eq(0).hide();
		$(".answer").toggle(
			function (){
				$(this).nextAll("textarea").eq(0).show();
			},
			function (){
				$(this).nextAll("textarea").eq(0).hide();
			}
		)
	}
)
 </script>